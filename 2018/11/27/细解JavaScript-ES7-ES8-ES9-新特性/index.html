<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      细解JavaScript ES7 ES8 ES9 新特性 | 拓跋的前端客栈 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="zhleven">
    
    

    <meta name="description" content="ECMAScript的演化不会停止，但是我们完全没必要害怕。除了ES6这个史无前例的版本带来了海量的信息和知识点以外，之后每年一发的版本都仅仅带有少量的增量更新，一年更新的东西花半个小时就能搞懂了，完全没必要畏惧。本文将带您花大约一个小时左右的时间，迅速过一遍ES7,ES8,ES9的新特性。">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="细解JavaScript ES7 ES8 ES9 新特性 | 拓跋的前端客栈">
<meta property="og:url" content="https://tuobaye0711.github.io/2018/11/27/细解JavaScript-ES7-ES8-ES9-新特性/index.html">
<meta property="og:site_name" content="拓跋的前端客栈">
<meta property="og:description" content="ECMAScript的演化不会停止，但是我们完全没必要害怕。除了ES6这个史无前例的版本带来了海量的信息和知识点以外，之后每年一发的版本都仅仅带有少量的增量更新，一年更新的东西花半个小时就能搞懂了，完全没必要畏惧。本文将带您花大约一个小时左右的时间，迅速过一遍ES7,ES8,ES9的新特性。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://tuobaye0711.github.io/2018/11/27/细解JavaScript-ES7-ES8-ES9-新特性/es_16_17_18.png">
<meta property="og:image" content="https://tuobaye0711.github.io/2018/11/27/细解JavaScript-ES7-ES8-ES9-新特性/es2016.png">
<meta property="og:image" content="https://tuobaye0711.github.io/2018/11/27/细解JavaScript-ES7-ES8-ES9-新特性/es2017.png">
<meta property="og:image" content="https://tuobaye0711.github.io/2018/11/27/细解JavaScript-ES7-ES8-ES9-新特性/es2018.png">
<meta property="og:image" content="https://tuobaye0711.github.io/2018/11/27/细解JavaScript-ES7-ES8-ES9-新特性/Unicode.png">
<meta property="og:updated_time" content="2018-11-28T01:21:58.978Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="细解JavaScript ES7 ES8 ES9 新特性 | 拓跋的前端客栈">
<meta name="twitter:description" content="ECMAScript的演化不会停止，但是我们完全没必要害怕。除了ES6这个史无前例的版本带来了海量的信息和知识点以外，之后每年一发的版本都仅仅带有少量的增量更新，一年更新的东西花半个小时就能搞懂了，完全没必要畏惧。本文将带您花大约一个小时左右的时间，迅速过一遍ES7,ES8,ES9的新特性。">
<meta name="twitter:image" content="https://tuobaye0711.github.io/2018/11/27/细解JavaScript-ES7-ES8-ES9-新特性/es_16_17_18.png">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">拓跋的前端客栈</a></h1>
        <hr class="panel-cover__divider">

        
        <p class="panel-cover__description">
          江湖的尽头是否只剩孤独
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



<nav class="cover-navigation navigation--social">
  <ul class="navigation">

    
      <!-- Github -->
      <li class="navigation__item">
        <a href="https://github.com/tuobaye0711" title="GitHub" target="view_window">
          <i class="icon icon-social-github"></i>
          <span class="label">GitHub</span>
        </a>
      </li>
      <!-- email -->
      <li class="navigation__item">
          <a href="mailto:tuobaye0711@163.com" title="Email" target="view_window">
              <i class="icon icon-mail"></i>
              <span class="label">mail</span>
          </a>
      </li>
      <!-- RSS -->
      <li class="navigation__item">
        <a href="/atom.xml" title="RSS" target="view_window">
            <i class="icon icon-rss"></i>
            <span class="label">RSS</span>
        </a>
    </li>
    

    <!-- China social icon -->
    <!--

      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-douban'></i>
          <span class="label">Douban</span>
        </a>
      </li>

      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-weibo'></i>
          <span class="label">Weibo</span>
        </a>
      </li>

    -->



  </ul>
</nav>



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">细解JavaScript ES7 ES8 ES9 新特性</h1>

    

    <div class="post-meta">
      <time datetime="2018-11-27" class="post-meta__date date">2018-11-27</time> 

      <span class="post-meta__tags tags">

          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/JavaScript/">JavaScript</a>
            </font>
          

      </span> | <span id="busuanzi_container_page_pv" style="font-size: 0.8em">
  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
</span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <p><img src="/2018/11/27/细解JavaScript-ES7-ES8-ES9-新特性/es_16_17_18.png" alt="es_16_17_18"></p>
<p>题记：本文提供了一个在线PPT版本，方便您浏览 <a href="https://tuobaye.com/demo/es7_es8_es9/" target="_blank" rel="noopener">细解JAVASCRIPT ES7 ES8 ES9 新特性 在线PPT ver</a></p>
<p>本文的大部分内容译自作者Axel Rauschmayer博士的网站，想了解更多关于作者的信息，可以浏览<a href="http://exploringjs.com/" target="_blank" rel="noopener">Exploring JS: JavaScript books for programmers</a></p>
<h2 id="那些与ECMAScript有关的事情"><a href="#那些与ECMAScript有关的事情" class="headerlink" title="那些与ECMAScript有关的事情"></a>那些与ECMAScript有关的事情</h2><h3 id="谁在设计ECMAScript"><a href="#谁在设计ECMAScript" class="headerlink" title="谁在设计ECMAScript?"></a>谁在设计ECMAScript?</h3><p>TC39 (Technical Committee 39)。</p>
<p>TC39 是推进 JavaScript 发展的委员会。其会员都是公司（其中主要是浏览器厂商）。TC39 定期召开会议，会议由会员公司的代表与特邀专家出席。会议纪录都可在网上查看，可以让你对 TC39 如何工作有一个清晰的概念。</p>
<p>很有意思的是，TC39 实行的是协商一致的原则：通过一项决议必须得到每一位会员（公司代表）的赞成。</p>
<h3 id="ECMAScript的发布周期"><a href="#ECMAScript的发布周期" class="headerlink" title="ECMAScript的发布周期"></a>ECMAScript的发布周期</h3><p>在2015年发布的 ECMAScript（ES6）新增内容很多，在 ES5 发布近 6 年（2009-11 至 2015-6）之后才将其标准化。两个发布版本之间时间跨度如此之大主要有两大原因：</p>
<ul>
<li>比新版率先完成的特性，必须等待新版的完成才能发布。</li>
<li>那些需要花长时间完成的特性，也顶着很大的压力被纳入这一版本，因为如果推迟到下一版本发布意味着又要等很久，这种特性也会推迟新的发布版本。</li>
</ul>
<p>因此，从 ECMAScript 2016（ES7）开始，版本发布变得更加频繁，每年发布一个新版本，这么一来新增内容也会更小。新版本将会包含每年截止时间之前完成的所有特性。</p>
<h3 id="ECMAScript的发布流程"><a href="#ECMAScript的发布流程" class="headerlink" title="ECMAScript的发布流程"></a>ECMAScript的发布流程</h3><p>每个 ECMAScript 特性的建议将会从阶段 0 开始， 然后经过下列几个成熟阶段。其中从一个阶段到下一个阶段必须经过 TC39 的批准。</p>
<ol>
<li><p>stage-0 - Strawman: just an idea, possible Babel plugin.<br>任何讨论、想法、改变或者还没加到提案的特性都在这个阶段。只有TC39成员可以提交。</p>
<p>当前的stage 0列表可以查看这里 –&gt; <a href="https://github.com/tc39/proposals/blob/master/stage-0-proposals.md" target="_blank" rel="noopener">Stage 0 Proposals</a></p>
</li>
<li><p>stage-1 - Proposal: this is worth working on.</p>
<p><strong>什么是 Proposal？</strong>一份新特性的正式建议文档。提案必须指明此建议的潜在问题，例如与其他特性之间的关联，实现难点等。</p>
</li>
<li><p>stage-2 - Draft: initial spec.</p>
<p><strong>什么是 Draft？</strong>草案是规范的第一个版本。其与最终标准中包含的特性不会有太大差别。</p>
<p>草案之后，原则上只接受增量修改。这个阶段开始实验如何实现，实现形式包括polyfill, 实现引擎（提供草案执行本地支持），或者编译转换（例如babel）</p>
</li>
<li><p>stage-3 - Candidate: complete spec and initial browser implementations.</p>
<p>候选阶段，获得具体实现和用户的反馈。此后，只有在实现和使用过程中出现了重大问题才会修改。至少要在一个浏览器中实现，提供polyfill或者babel插件。</p>
</li>
<li><p>stage-4 - Finished: will be added to the next yearly release.</p>
<p>已经准备就绪，该特性会出现在下个版本的ECMAScript规范之中。</p>
<p>当前的stage 1-3列表可以查看这里 –&gt; <a href="https://github.com/tc39/proposals" target="_blank" rel="noopener">ECMAScript proposals</a></p>
</li>
</ol>
<h3 id="已经正式发布的特性索引"><a href="#已经正式发布的特性索引" class="headerlink" title="已经正式发布的特性索引"></a>已经正式发布的特性索引</h3><table>
<thead>
<tr>
<th>Proposal</th>
<th>Author</th>
<th>Champion(s)</th>
<th>TC39 meeting notes</th>
<th>Expected Publication Year</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/tc39/Array.prototype.includes" target="_blank" rel="noopener"><code>Array.prototype.includes</code></a></td>
<td>Domenic Denicola</td>
<td>Domenic Denicola<br>Rick Waldron</td>
<td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es7/2015-11/nov-17.md#arrayprototypeincludes" target="_blank" rel="noopener">November 2015</a></td>
<td>2016</td>
</tr>
<tr>
<td><a href="https://github.com/rwaldron/exponentiation-operator" target="_blank" rel="noopener">Exponentiation operator</a></td>
<td>Rick Waldron</td>
<td>Rick Waldron</td>
<td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es7/2016-01/2016-01-28.md#5xviii-exponentiation-operator-rw" target="_blank" rel="noopener">January 2016</a></td>
<td>2016</td>
</tr>
<tr>
<td><a href="https://github.com/tc39/proposal-object-values-entries" target="_blank" rel="noopener"><code>Object.values</code>/<code>Object.entries</code></a></td>
<td>Jordan Harband</td>
<td>Jordan Harband</td>
<td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es7/2016-03/march-29.md#objectvalues--objectentries" target="_blank" rel="noopener">March 2016</a></td>
<td>2017</td>
</tr>
<tr>
<td><a href="https://github.com/tc39/proposal-string-pad-start-end" target="_blank" rel="noopener">String padding</a></td>
<td>Jordan Harband</td>
<td>Jordan Harband<br>Rick Waldron</td>
<td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es7/2016-05/may-25.md#stringprototypepadstartend-jhd" target="_blank" rel="noopener">May 2016</a></td>
<td>2017</td>
</tr>
<tr>
<td><a href="https://github.com/ljharb/proposal-object-getownpropertydescriptors" target="_blank" rel="noopener"><code>Object.getOwnPropertyDescriptors</code></a></td>
<td>Jordan Harband<br>Andrea Giammarchi</td>
<td>Jordan Harband<br>Andrea Giammarchi</td>
<td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es7/2016-05/may-25.md#objectgetownpropertydescriptors-jhd" target="_blank" rel="noopener">May 2016</a></td>
<td>2017</td>
</tr>
<tr>
<td><a href="https://github.com/tc39/proposal-trailing-function-commas" target="_blank" rel="noopener">Trailing commas in function parameter lists and calls</a></td>
<td>Jeff Morrison</td>
<td>Jeff Morrison</td>
<td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es7/2016-07/jul-26.md#9ie-trailing-commas-in-functions" target="_blank" rel="noopener">July 2016</a></td>
<td>2017</td>
</tr>
<tr>
<td><a href="https://github.com/tc39/ecmascript-asyncawait" target="_blank" rel="noopener">Async functions</a></td>
<td>Brian Terlson</td>
<td>Brian Terlson</td>
<td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es7/2016-07/jul-28.md#10iv-async-functions" target="_blank" rel="noopener">July 2016</a></td>
<td>2017</td>
</tr>
<tr>
<td><a href="https://github.com/tc39/ecmascript_sharedmem" target="_blank" rel="noopener">Shared memory and atomics</a></td>
<td>Lars T Hansen</td>
<td>Lars T Hansen</td>
<td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es7/2017-01/jan-24.md#13if-seeking-stage-4-for-sharedarraybuffer" target="_blank" rel="noopener">January 2017</a></td>
<td>2017</td>
</tr>
<tr>
<td><a href="https://github.com/tc39/proposal-template-literal-revision" target="_blank" rel="noopener">Lifting template literal restriction</a></td>
<td>Tim Disney</td>
<td>Tim Disney</td>
<td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es8/2017-03/mar-21.md#10ia-template-literal-updates" target="_blank" rel="noopener">March 2017</a></td>
<td>2018</td>
</tr>
<tr>
<td><a href="https://github.com/tc39/proposal-regexp-dotall-flag" target="_blank" rel="noopener"><code>s</code> (<code>dotAll</code>) flag for regular expressions</a></td>
<td>Mathias Bynens</td>
<td>Brian Terlson<br>Mathias Bynens</td>
<td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es8/2017-11/nov-28.md#9ie-regexp-dotall-status-update" target="_blank" rel="noopener">November 2017</a></td>
<td>2018</td>
</tr>
<tr>
<td><a href="https://github.com/tc39/proposal-regexp-named-groups" target="_blank" rel="noopener">RegExp named capture groups</a></td>
<td>Gorkem Yakin<br>Daniel Ehrenberg</td>
<td>Daniel Ehrenberg<br>Brian Terlson<br>Mathias Bynens</td>
<td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es8/2017-11/nov-28.md#9if-regexp-named-captures-status-update" target="_blank" rel="noopener">November 2017</a></td>
<td>2018</td>
</tr>
<tr>
<td><a href="https://github.com/tc39/proposal-object-rest-spread" target="_blank" rel="noopener">Rest/Spread Properties</a></td>
<td>Sebastian Markbåge</td>
<td>Sebastian Markbåge</td>
<td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es8/2018-01/jan-23.md#restspread-properties-for-stage-4" target="_blank" rel="noopener">January 2018</a></td>
<td>2018</td>
</tr>
<tr>
<td><a href="https://github.com/tc39/proposal-regexp-lookbehind" target="_blank" rel="noopener">RegExp Lookbehind Assertions</a></td>
<td>Gorkem Yakin<br>Nozomu Katō<br>Daniel Ehrenberg</td>
<td>Daniel Ehrenberg<br>Mathias Bynens</td>
<td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es8/2018-01/jan-23.md#conclusionresolution-16" target="_blank" rel="noopener">January 2018</a></td>
<td>2018</td>
</tr>
<tr>
<td><a href="https://github.com/tc39/proposal-regexp-unicode-property-escapes" target="_blank" rel="noopener">RegExp Unicode Property Escapes</a></td>
<td>Mathias Bynens</td>
<td>Brian Terlson<br>Daniel Ehrenberg<br>Mathias Bynens</td>
<td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es8/2018-01/jan-24.md#conclusionresolution-1" target="_blank" rel="noopener">January 2018</a></td>
<td>2018</td>
</tr>
<tr>
<td><a href="https://github.com/tc39/proposal-promise-finally" target="_blank" rel="noopener"><code>Promise.prototype.finally</code></a></td>
<td>Jordan Harband</td>
<td>Jordan Harband</td>
<td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es8/2018-01/jan-24.md#conclusionresolution-2" target="_blank" rel="noopener">January 2018</a></td>
<td>2018</td>
</tr>
<tr>
<td><a href="https://github.com/tc39/proposal-async-iteration" target="_blank" rel="noopener">Asynchronous Iteration</a></td>
<td>Domenic Denicola</td>
<td>Domenic Denicola</td>
<td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es8/2018-01/jan-25.md#conclusionresolution" target="_blank" rel="noopener">January 2018</a></td>
<td>2018</td>
</tr>
<tr>
<td><a href="https://github.com/tc39/proposal-optional-catch-binding" target="_blank" rel="noopener">Optional <code>catch</code> binding</a></td>
<td>Michael Ficarra</td>
<td>Michael Ficarra</td>
<td>May 2018</td>
<td>2019</td>
</tr>
<tr>
<td><a href="https://github.com/tc39/proposal-json-superset" target="_blank" rel="noopener">JSON superset</a></td>
<td>Richard Gibson</td>
<td>Mark Miller<br>Mathias Bynens</td>
<td>May 2018</td>
<td>2019</td>
</tr>
</tbody>
</table>
<h2 id="ES7新特性（ECMAScript-2016）"><a href="#ES7新特性（ECMAScript-2016）" class="headerlink" title="ES7新特性（ECMAScript 2016）"></a>ES7新特性（ECMAScript 2016）</h2><p><img src="/2018/11/27/细解JavaScript-ES7-ES8-ES9-新特性/es2016.png" alt="ECMAScript 2016"></p>
<p>ES7在ES6的基础上主要添加了两项内容：</p>
<ul>
<li>Array.prototype.includes()方法</li>
<li>求幂运算符（**）</li>
</ul>
<h3 id="Array-prototype-includes-方法"><a href="#Array-prototype-includes-方法" class="headerlink" title="Array.prototype.includes()方法"></a>Array.prototype.includes()方法</h3><p>includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var array = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">console.log(array.includes(2));</span><br><span class="line">// expected output: true</span><br><span class="line"></span><br><span class="line">var pets = [&apos;cat&apos;, &apos;dog&apos;, &apos;bat&apos;];</span><br><span class="line"></span><br><span class="line">console.log(pets.includes(&apos;cat&apos;));</span><br><span class="line">// expected output: true</span><br><span class="line"></span><br><span class="line">console.log(pets.includes(&apos;at&apos;));</span><br><span class="line">// expected output: false</span><br></pre></td></tr></table></figure>
<p>Array.prototype.includes()方法接收两个参数：</p>
<ul>
<li>要搜索的值</li>
<li>搜索的开始索引。</li>
</ul>
<p>当第二个参数被传入时，该方法会从索引处开始往后搜索（默认索引值为0）。若搜索值在数组中存在则返回true，否则返回false。 且看下面示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;].includes(&apos;b&apos;)         // true</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;].includes(&apos;b&apos;, 1)      // true</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;].includes(&apos;b&apos;, 2)      // false</span><br></pre></td></tr></table></figure>
<p>–</p>
<p>乍一看，includes的作用跟数组的indexOf重叠，为什么要特意增加这么一个api呢？主要区别有以下几点：</p>
<ul>
<li>返回值。看一个函数，先看他们的返回值。indexOf的返回数是值型的，includes的返回值是布尔型，所以在if条件判断的时候includes要简单得多，而indexOf 需要多写一个条件进行判断。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var ary = [1];</span><br><span class="line">if (ary.indexOf(1) !== -1) &#123;</span><br><span class="line">    console.log(&quot;数组存在1&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if (ary.includes(1)) &#123;</span><br><span class="line">    console.log(&quot;数组存在1&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>NaN的判断。如果数组中有NaN，你又正好需要判断数组是否有存在NaN，这时你使用indexOf是无法判断的，你必须使用includes这个方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var ary1 = [NaN];</span><br><span class="line">console.log(ary1.indexOf(NaN))//-1</span><br><span class="line">console.log(ary1.includes(NaN))//true</span><br></pre></td></tr></table></figure>
<ul>
<li>当数组的有空的值的时候，includes会认为空的值是undefined，而indexOf不会。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var ary1 = new Array(3);</span><br><span class="line">console.log(ary1.indexOf(undefined));//-1</span><br><span class="line">console.log(ary1.includes(undefined))//true</span><br></pre></td></tr></table></figure>
<h3 id="求幂运算符（-）"><a href="#求幂运算符（-）" class="headerlink" title="求幂运算符（**）"></a>求幂运算符（**）</h3><p>加/减法我们通常都是用其中缀形式，直观易懂。在ECMAScript2016中，我们可以使用<code>**</code>来替代Math.pow。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> ** <span class="number">3</span>           <span class="comment">// 64</span></span><br></pre></td></tr></table></figure>
<p>效果等同于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">4</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>值得一提的是，作为中缀运算符，**还支持以下操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">4</span>;</span><br><span class="line">n **= <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 64</span></span><br></pre></td></tr></table></figure>
<h2 id="ES8新特性（ECMAScript-2017）"><a href="#ES8新特性（ECMAScript-2017）" class="headerlink" title="ES8新特性（ECMAScript 2017）"></a>ES8新特性（ECMAScript 2017）</h2><p><img src="/2018/11/27/细解JavaScript-ES7-ES8-ES9-新特性/es2017.png" alt="ECMAScript 2017"></p>
<p>在2017年1月的TC39会议上，ECMAScript 2017的最后一个功能“Shared memory and atomics”推进到第4阶段。这意味着它的功能集现已完成。</p>
<p>ECMAScript 2017特性一览</p>
<p>主要新功能：</p>
<ul>
<li>异步函数 Async Functions（Brian Terlson）</li>
<li>共享内存和Atomics（Lars T. Hansen）</li>
</ul>
<p>次要新功能：</p>
<ul>
<li>Object.values / Object.entries（Jordan Harband）</li>
<li>String padding（Jordan Harband，Rick Waldron）</li>
<li>Object.getOwnPropertyDescriptors() （Jordan Harband，Andrea Giammarchi）</li>
<li>函数参数列表和调用中的尾逗号（Jeff Morrison）</li>
</ul>
<h3 id="Async-Functions"><a href="#Async-Functions" class="headerlink" title="Async Functions"></a>Async Functions</h3><p>Async Functions也就是我们常说的Async/Await，相信大家对于这个概念都已经不陌生了。Async/Await是一种用于处理JS异步操作的语法糖，可以帮助我们摆脱回调地狱，编写更加优雅的代码。</p>
<p>通俗的理解，async关键字的作用是告诉编译器对于标定的函数要区别对待。当编译器遇到标定的函数中的await关键字时，要暂时停止运行，带到await标定的函数处理完毕后，再进行相应操作。如果该函数fulfiled了，则返回值是fulfillment value，否则得到的就是reject value。</p>
<p>下面通过拿普通的promise写法来对比，就很好理解了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> otherAsyncFunc();</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Equivalent to:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> otherAsyncFunc()</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按顺序处理多个异步函数的时候优势更为明显：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result1 = <span class="keyword">await</span> otherAsyncFunc1();</span><br><span class="line">    <span class="built_in">console</span>.log(result1);</span><br><span class="line">    <span class="keyword">const</span> result2 = <span class="keyword">await</span> otherAsyncFunc2();</span><br><span class="line">    <span class="built_in">console</span>.log(result2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Equivalent to:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> otherAsyncFunc1()</span><br><span class="line">    .then(<span class="function"><span class="params">result1</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result1);</span><br><span class="line">        <span class="keyword">return</span> otherAsyncFunc2();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result2</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并行处理多个异步函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [result1, result2] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">        otherAsyncFunc1(),</span><br><span class="line">        otherAsyncFunc2(),</span><br><span class="line">    ]);</span><br><span class="line">    <span class="built_in">console</span>.log(result1, result2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Equivalent to:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">        otherAsyncFunc1(),</span><br><span class="line">        otherAsyncFunc2(),</span><br><span class="line">    ])</span><br><span class="line">    .then([result1, result2] =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result1, result2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> otherAsyncFunc();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Equivalent to:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> otherAsyncFunc()</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Async Functions若是要展开去讲，可以占用很大段的篇幅。鉴于本文是一篇介绍性文章，再次不再进行深入。</p>
<h3 id="SharedArrayBuffer和Atomics"><a href="#SharedArrayBuffer和Atomics" class="headerlink" title="SharedArrayBuffer和Atomics"></a>SharedArrayBuffer和Atomics</h3><p><strong>注</strong>，如果之前您没有接触过ArrayBuffer相关知识的话，建议您从内存管理速成教程系列漫画解说入门，强推：<br><a href="https://hacks.mozilla.org/2017/06/a-crash-course-in-memory-management/" target="_blank" rel="noopener">A crash course in memory management</a><br><a href="https://hacks.mozilla.org/2017/06/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers/" target="_blank" rel="noopener">A cartoon intro to ArrayBuffers and SharedArrayBuffers
</a><br><a href="https://hacks.mozilla.org/2017/06/avoiding-race-conditions-in-sharedarraybuffers-with-atomics/" target="_blank" rel="noopener">Avoiding race conditions in SharedArrayBuffers with Atomics
</a></p>
<hr>
<p>ECMAScript 2017 特性 SharedArrayBuffer 和 atomics”，由Lars T. Hansen设计。它引入了一个新的构造函数 SharedArrayBuffer 和 具有辅助函数的命名空间对象 Atomics。</p>
<p>在我们开始之前，让我们澄清两个相似但截然不同的术语：并行(Parallelism) 和 并发(Concurrency) 。他们存在许多定义，我使用的定义如下</p>
<ul>
<li>并行(Parallelism) (parallel 并行 vs. serial 串行)：同时执行多个任务；</li>
<li>并发(Concurrency) (concurrent 并发 vs. sequential 连续)：在重叠的时间段内（而不是一个接一个）执行几个任务。</li>
</ul>
<h4 id="JS并行的历史"><a href="#JS并行的历史" class="headerlink" title="JS并行的历史"></a>JS并行的历史</h4><ul>
<li>JavaScript 在单线程中执行。某些任务可以异步执行：浏览器通常会在单线程中运行这些任务，然后通过回调将结果重新加入到单线程中。</li>
<li>Web workers 将任务并行引入了 JavaScript ：这些是相对重量级的进程。每个 workers 都有自己的全局环境。默认情况下，不共享任何内容。 workers 之间的通信（或在 workers 和主线程之间的通信）发展：<ul>
<li>起初，你只能发送和接收字符串。</li>
<li>然后，引入结构化克隆：可以发送和接收数据副本。结构化克隆适用于大多数数据（JSON 数据，TypedArray，正则表达式，Blob对象，ImageData对象等）。它甚至可以正确处理对象之间的循环引用。但是，不能克隆 error 对象，function 对象和 DOM 节点。</li>
<li>可在 workers 之间的转移数据:当接收方获得数据时，发送方失去访问权限。</li>
</ul>
</li>
<li>通过 WebGL 使用 GPU 计算(它倾向于数据并行处理) </li>
</ul>
<h4 id="共享数组缓冲区（Shared-Array-Buffers）"><a href="#共享数组缓冲区（Shared-Array-Buffers）" class="headerlink" title="共享数组缓冲区（Shared Array Buffers）"></a>共享数组缓冲区（Shared Array Buffers）</h4><p>共享阵列缓冲区是更高并发抽象的基本构建块。它们允许您在多个 workers 和主线程之间共享 SharedArrayBuffer 对象的字节(该缓冲区是共享的，用于访问字节，将其封装在一个 TypedArray 中)这种共享有两个好处：</p>
<p>你可以更快地在 workers 之间共享数据。<br>workers 之间的协调变得更简单和更快（与 postMessage() 相比）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(<span class="string">'worker.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要分享的buffer</span></span><br><span class="line"><span class="keyword">const</span> sharedBuffer = <span class="keyword">new</span> SharedArrayBuffer( <span class="comment">// (A)</span></span><br><span class="line">    <span class="number">10</span> * <span class="built_in">Int32Array</span>.BYTES_PER_ELEMENT); <span class="comment">// 10 elements</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Worker共用sharedBuffer</span></span><br><span class="line">worker.postMessage(&#123;sharedBuffer&#125;); <span class="comment">// clone</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅限本地使用</span></span><br><span class="line"><span class="keyword">const</span> sharedArray = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(sharedBuffer); <span class="comment">// (B)</span></span><br></pre></td></tr></table></figure>
<p>创建一个共享数组缓冲区（Shared Array Buffers）的方法与创建普通的数组缓冲区(Array Buffer)类似：通过调用构造函数，并以字节的形式指定缓冲区的大小(行A)。你与 workers 共享的是 缓冲区（buffer） 。对于你自己的本地使用，你通常将共享数组缓冲区封装在 TypedArray 中(行B)。</p>
<p>workers的实现如下所列。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line">self.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;sharedBuffer&#125; = event.data;</span><br><span class="line">    <span class="keyword">const</span> sharedArray = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(sharedBuffer); <span class="comment">// (A)</span></span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="sharedArrayBuffer-的-API"><a href="#sharedArrayBuffer-的-API" class="headerlink" title="sharedArrayBuffer 的 API"></a>sharedArrayBuffer 的 API</h4><p>构造函数：</p>
<ul>
<li>new SharedArrayBuffer(length)<br>创建一个 length 字节的 buffer(缓冲区)。</li>
</ul>
<p>静态属性：</p>
<ul>
<li>get SharedArrayBuffer[Symbol.species]<br>默认情况下返回 this。 覆盖以控制 slice() 的返回。</li>
</ul>
<p>实例属性：</p>
<ul>
<li><p>get SharedArrayBuffer.prototype.byteLength()<br>返回 buffer(缓冲区) 的字节长度。</p>
</li>
<li><p>SharedArrayBuffer.prototype.slice(start, end)<br>创建一个新的 this.constructor[Symbol.species] 实例，并用字节填充从（包括）开始到（不包括）结束的索引。</p>
</li>
</ul>
<h4 id="Atomics-安全访问共享数据"><a href="#Atomics-安全访问共享数据" class="headerlink" title="Atomics: 安全访问共享数据"></a>Atomics: 安全访问共享数据</h4><p>举一个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">sharedArray[<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">sharedArray[<span class="number">2</span>] = <span class="number">22</span>;</span><br></pre></td></tr></table></figure>
<p>在单线程中，您可以重新排列这些写入操作，因为在中间没有读到任何内容。 对于多线程，当你期望以特定顺序执行写入操作时，就会遇到麻烦：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">while</span> (sharedArray[<span class="number">2</span>] !== <span class="number">22</span>) ;</span><br><span class="line"><span class="built_in">console</span>.log(sharedArray[<span class="number">1</span>]); <span class="comment">// 0 or 11</span></span><br></pre></td></tr></table></figure>
<p>Atomics 方法可以用来与其他 workers 进行同步。例如，以下两个操作可以让你读取和写入数据，并且不会被编译器重新排列：</p>
<ul>
<li>Atomics.load(ta : TypedArray, index)</li>
<li>Atomics.store(ta : TypedArray, index, value : T)</li>
<li>这个想法是使用常规操作读取和写入大多数数据，而 Atomics 操作（load ，store 和其他操作）可确保读取和写入安全。通常，您将使用自定义同步机制，例如锁，其实现基于Atomics。</li>
</ul>
<p>这是一个非常简单的例子，它总是有效的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'notifying...'</span>);</span><br><span class="line">Atomics.store(sharedArray, <span class="number">0</span>, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">while</span> (Atomics.load(sharedArray, <span class="number">0</span>) !== <span class="number">123</span>) ;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'notified'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Atomics-的-API"><a href="#Atomics-的-API" class="headerlink" title="Atomics 的 API"></a>Atomics 的 API</h4><p>Atomic 函数的主要操作数必须是 Int8Array ，Uint8Array ，Int16Array ，Uint16Array ，Int32Array 或 Uint32Array 的一个实例。它必须包裹一个 SharedArrayBuffer 。</p>
<p>所有函数都以 atomically 方式进行操作。存储操作的顺序是固定的并且不能由编译器或 CPU 重新排序。</p>
<p>加载和存储</p>
<ul>
<li>Atomics.load(ta : TypedArray<t>, index) : T<br>读取和返回 ta[index] 上的元素，返回数组指定位置上的值。</t></li>
<li>Atomics.store(ta : TypedArray<t>, index, value : T) : T<br>在 ta[index] 上写入 value，并且返回 value。</t></li>
<li>Atomics.exchange(ta : TypedArray<t>, index, value : T) : T<br>将 ta[index] 上的元素设置为 value ，并且返回索引 index 原先的值。</t></li>
<li>Atomics.compareExchange(ta : TypedArray<t>, index, expectedValue, replacementValue) : T<br>如果 ta[index] 上的当前元素为 expectedValue , 那么使用 replacementValue 替换。并且返回索引 index 原先（或者未改变）的值。</t></li>
</ul>
<p>简单修改 TypeArray 元素</p>
<p>以下每个函数都会在给定索引处更改 TypeArray 元素：它将一个操作符应用于元素和参数，并将结果写回元素。它返回元素的原始值。</p>
<ul>
<li>Atomics.add(ta : TypedArray<t>, index, value) : T<br>执行 ta[index] += value 并返回 ta[index] 的原始值。</t></li>
<li>Atomics.sub(ta : TypedArray<t>, index, value) : T<br>执行 ta[index] -= value 并返回 ta[index] 的原始值。</t></li>
<li>Atomics.and(ta : TypedArray<t>, index, value) : T<br>执行 ta[index] &amp;= value 并返回 ta[index] 的原始值。</t></li>
<li>Atomics.or(ta : TypedArray<t>, index, value) : T<br>执行 ta[index] |= value 并返回 ta[index] 的原始值。</t></li>
<li>Atomics.xor(ta : TypedArray<t>, index, value) : T<br>执行 ta[index] ^= value 并返回 ta[index] 的原始值。</t></li>
</ul>
<p>等待和唤醒</p>
<ul>
<li>Atomics.wait(ta: Int32Array, index, value, timeout=Number.POSITIVE_INFINITY) : (‘not-equal’ | ‘ok’ | ‘timed-out’)<br>如果 ta[index] 的当前值不是 value ，则返回 ‘not-equal’。否则继续等待，直到我们通过 Atomics.wake() 唤醒或直到等待超时。 在前一种情况下，返回 ‘ok’。在后一种情况下，返回’timed-out’。timeout 以毫秒为单位。记住此函数执行的操作：“如果 ta[index] 为 value，那么继续等待” 。</li>
<li>Atomics.wake(ta : Int32Array, index, count)<br>唤醒等待在 ta[index] 上的 count workers。</li>
</ul>
<h3 id="Object-values-and-Object-entries"><a href="#Object-values-and-Object-entries" class="headerlink" title="Object.values and Object.entries"></a>Object.values and Object.entries</h3><p>Object.values() 方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for…in循环的顺序相同 ( 区别在于for-in循环枚举原型链中的属性 )。</p>
<p>obj参数是需要待操作的对象。可以是一个对象，或者一个数组（是一个带有数字下标的对象，[10,20,30] -&gt; {0: 10,1: 20,2: 30})。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">x</span>: <span class="string">'xxx'</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj); <span class="comment">// ['xxx', 1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = [<span class="string">'e'</span>, <span class="string">'s'</span>, <span class="string">'8'</span>]; <span class="comment">// 相当于 &#123; 0: 'e', 1: 's', 2: '8' &#125;;</span></span><br><span class="line"><span class="built_in">Object</span>.values(obj); <span class="comment">// ['e', 's', '8']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们使用数字键值时，返回的是数字排序</span></span><br><span class="line"><span class="comment">// 根据键值排序</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">10</span>: <span class="string">'xxx'</span>, <span class="number">1</span>: <span class="string">'yyy'</span>, <span class="number">3</span>: <span class="string">'zzz'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj); <span class="comment">// ['yyy', 'zzz', 'xxx']</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.values(<span class="string">'es8'</span>); <span class="comment">// ['e', 's', '8']</span></span><br></pre></td></tr></table></figure>
<p>Object.entries 方法返回一个给定对象自身可遍历属性 [key, value] 的数组， 排序规则和 Object.values 一样。这个方法的声明比较琐碎:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">x</span>: <span class="string">'xxx'</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj); <span class="comment">// [['x', 'xxx'], ['y', 1]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = [<span class="string">'e'</span>, <span class="string">'s'</span>, <span class="string">'8'</span>];</span><br><span class="line"><span class="built_in">Object</span>.entries(obj); <span class="comment">// [['0', 'e'], ['1', 's'], ['2', '8']]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">10</span>: <span class="string">'xxx'</span>, <span class="number">1</span>: <span class="string">'yyy'</span>, <span class="number">3</span>: <span class="string">'zzz'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj); <span class="comment">// [['1', 'yyy'], ['3', 'zzz'], ['10': 'xxx']]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.entries(<span class="string">'es8'</span>); <span class="comment">// [['0', 'e'], ['1', 's'], ['2', '8']]</span></span><br></pre></td></tr></table></figure>
<h3 id="String-padding"><a href="#String-padding" class="headerlink" title="String padding"></a>String padding</h3><p>为 String 对象增加了 2 个函数：padStart 和 padEnd。</p>
<p>像它们名字那样，这几个函数的主要目的就是填补字符串的首部和尾部，为了使得到的结果字符串的长度能达到给定的长度。你可以通过特定的字符，或者字符串，或者默认的空格填充它。下面是函数的声明：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.padStart(targetLength [, padString])</span><br><span class="line">str.padEnd(targetLength [, padString])</span><br></pre></td></tr></table></figure>
<p>这些函数的第一个参数是 targetLength（目标长度），这个是结果字符串的长度。第二个参数是可选的 padString（填充字符），一个用于填充到源字符串的字符串。默认值是空格。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'es8'</span>.padStart(<span class="number">2</span>);          <span class="comment">// 'es8'</span></span><br><span class="line"><span class="string">'es8'</span>.padStart(<span class="number">5</span>);          <span class="comment">// '  es8'</span></span><br><span class="line"><span class="string">'es8'</span>.padStart(<span class="number">6</span>, <span class="string">'woof'</span>);  <span class="comment">// 'wooes8'</span></span><br><span class="line"><span class="string">'es8'</span>.padStart(<span class="number">14</span>, <span class="string">'wow'</span>);  <span class="comment">// 'wowwowwowwoes8'</span></span><br><span class="line"><span class="string">'es8'</span>.padStart(<span class="number">7</span>, <span class="string">'0'</span>);     <span class="comment">// '0000es8'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'es8'</span>.padEnd(<span class="number">2</span>);            <span class="comment">// 'es8'</span></span><br><span class="line"><span class="string">'es8'</span>.padEnd(<span class="number">5</span>);            <span class="comment">// 'es8  '</span></span><br><span class="line"><span class="string">'es8'</span>.padEnd(<span class="number">6</span>, <span class="string">'woof'</span>);    <span class="comment">// 'es8woo'</span></span><br><span class="line"><span class="string">'es8'</span>.padEnd(<span class="number">14</span>, <span class="string">'wow'</span>);    <span class="comment">// 'es8wowwowwowwo'</span></span><br><span class="line"><span class="string">'es8'</span>.padEnd(<span class="number">7</span>, <span class="string">'6'</span>);       <span class="comment">// 'es86666'</span></span><br></pre></td></tr></table></figure>
<h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a>Object.getOwnPropertyDescriptors</h3><p>getOwnPropertyDescriptors 方法返回指定对象所有自身属性的描述对象。属性描述对象是直接在对象上定义的，而不是继承于对象的原型。ES2017加入这个函数的主要动机在于方便将一个对象深度拷贝给另一个对象，同时可以将getter/setter拷贝。声明如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br></pre></td></tr></table></figure>
<p>obj 是待操作对象。返回的描述对象键值有：configurable, enumerable, writable, get, set and value。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; </span><br><span class="line">  get es7() &#123; <span class="keyword">return</span> <span class="number">777</span>; &#125;,</span><br><span class="line">  get es8() &#123; <span class="keyword">return</span> <span class="number">888</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   es7: &#123;</span></span><br><span class="line"><span class="comment">//     configurable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     get: function es7()&#123;&#125;, //the getter function</span></span><br><span class="line"><span class="comment">//     set: undefined</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   es8: &#123;</span></span><br><span class="line"><span class="comment">//     configurable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     get: function es8()&#123;&#125;, //the getter function</span></span><br><span class="line"><span class="comment">//     set: undefined</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="结尾逗号"><a href="#结尾逗号" class="headerlink" title="结尾逗号"></a>结尾逗号</h3><p>结尾逗号用代码展示非常明了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数定义时</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    param1,</span></span></span><br><span class="line"><span class="function"><span class="params">    param2,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用时</span></span><br><span class="line">foo(</span><br><span class="line">    <span class="string">'abc'</span>,</span><br><span class="line">    <span class="string">'def'</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象中</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    first: <span class="string">'Jane'</span>,</span><br><span class="line">    last: <span class="string">'Doe'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组中</span></span><br><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">    <span class="string">'red'</span>,</span><br><span class="line">    <span class="string">'green'</span>,</span><br><span class="line">    <span class="string">'blue'</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>这个改动有什么好处呢？</p>
<ul>
<li>首先，重新排列项目更简单，因为如果最后一项更改其位置，则不必添加和删除逗号。</li>
<li>其次，它可以帮助版本控制系统跟踪实际发生的变化。例如，从：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">'foo'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">'foo'</span>,</span><br><span class="line">    <span class="string">'bar'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>导致线条’foo’和线条’bar’被标记为已更改，即使唯一真正的变化是后一条线被添加。</p>
<h2 id="ES9新特性（ECMAScript-2018）"><a href="#ES9新特性（ECMAScript-2018）" class="headerlink" title="ES9新特性（ECMAScript 2018）"></a>ES9新特性（ECMAScript 2018）</h2><p><img src="/2018/11/27/细解JavaScript-ES7-ES8-ES9-新特性/es2018.png" alt="ECMAScript 2017"></p>
<p>ES9的新特性索引如下：</p>
<p>主要新功能：</p>
<ul>
<li>异步迭代（Domenic Denicola，Kevin Smith）</li>
<li>Rest/Spread 属性（SebastianMarkbåge）</li>
</ul>
<p>新的正则表达式功能：</p>
<ul>
<li>RegExp named capture groups（Gorkem Yakin，Daniel Ehrenberg）</li>
<li>RegExp Unicode Property Escapes（Mathias Bynens）</li>
<li>RegExp Lookbehind Assertions（Gorkem Yakin，NozomuKatō，Daniel Ehrenberg）</li>
<li>s (dotAll) flag for regular expressions（Mathias Bynens）</li>
</ul>
<p>其他新功能：</p>
<ul>
<li>Promise.prototype.finally() （Jordan Harband）</li>
<li>模板字符串修改（Tim Disney）</li>
</ul>
<h3 id="异步迭代"><a href="#异步迭代" class="headerlink" title="异步迭代"></a>异步迭代</h3><h4 id="首先来回顾一下同步迭代器："><a href="#首先来回顾一下同步迭代器：" class="headerlink" title="首先来回顾一下同步迭代器："></a>首先来回顾一下同步迭代器：</h4><p>ES6引入了同步迭代器，其工作原理如下：</p>
<ul>
<li>Iterable：一个对象，表示可以通过Symbol.iterator方法进行迭代。</li>
<li>Iterator：通过调用iterable [Symbol.iterator] ()返回的对象。它将每个迭代元素包装在一个对象中，并通过其next()方法一次返回一个。</li>
<li>IteratorResult：返回的对象next()。属性value包含一个迭代的元素，属性done是true 后最后一个元素。</li>
</ul>
<p>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iterable = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line"><span class="keyword">const</span> iterator = iterable[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">iterator.next()</span><br><span class="line"><span class="comment">// &#123; value: 'a', done: false &#125;</span></span><br><span class="line">iterator.next()</span><br><span class="line"><span class="comment">// &#123; value: 'b', done: false &#125;</span></span><br><span class="line">iterator.next()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="异步迭代器"><a href="#异步迭代器" class="headerlink" title="异步迭代器"></a>异步迭代器</h4><p>先前的迭代方式是同步的，并不适用于异步数据源。例如，在以下代码中，readLinesFromFile()无法通过同步迭代传递其异步数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> line <span class="keyword">of</span> readLinesFromFile(fileName)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步迭代器和常规迭代器的工作方式非常相似，但是异步迭代器涉及promise:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 普通迭代器:</span></span><br><span class="line">  <span class="keyword">const</span> iterator = createNumberIterator();</span><br><span class="line">  iterator.next(); <span class="comment">// Object &#123;value: 1, done: false&#125;</span></span><br><span class="line">  iterator.next(); <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">  iterator.next(); <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">  iterator.next(); <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步迭代器:</span></span><br><span class="line">  <span class="keyword">const</span> asyncIterator = createAsyncNumberIterator();</span><br><span class="line">  <span class="keyword">const</span> p = asyncIterator.next(); <span class="comment">// Promise</span></span><br><span class="line">  <span class="keyword">await</span> p;<span class="comment">// Object &#123;value: 1, done: false&#125;</span></span><br><span class="line">  <span class="keyword">await</span> asyncIterator.next(); <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">  <span class="keyword">await</span> asyncIterator.next(); <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">  <span class="keyword">await</span> asyncIterator.next(); <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步迭代器对象的next()方法返回了一个Promise，解析后的值跟普通的迭代器类似。<br>用法：<code>iterator.next().then(({ value, done })=&gt; {//{value: ‘some val’, done: false}}</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="number">1</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="number">2</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="number">3</span>)),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> p <span class="keyword">of</span> promises) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">//1 ,2 3</span></span><br></pre></td></tr></table></figure>
<h3 id="Rest-Spread-属性"><a href="#Rest-Spread-属性" class="headerlink" title="Rest/Spread 属性"></a>Rest/Spread 属性</h3><p>这个就是我们通常所说的rest参数和扩展运算符，这项特性在ES6中已经引入，但是ES6中的作用对象仅限于数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">restParam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restParam</span>(<span class="params">p1, p2, ...p3</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// p1 = 1</span></span><br><span class="line">  <span class="comment">// p2 = 2</span></span><br><span class="line">  <span class="comment">// p3 = [3, 4, 5]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> values = [<span class="number">99</span>, <span class="number">100</span>, <span class="number">-1</span>, <span class="number">48</span>, <span class="number">16</span>];</span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.max(...values) ); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<p>在ES9中，为对象提供了像数组一样的rest参数和扩展运算符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; a, ...param &#125; = obj;</span><br><span class="line">  <span class="built_in">console</span>.log(a)     <span class="comment">//1</span></span><br><span class="line">  <span class="built_in">console</span>.log(param) <span class="comment">//&#123;b: 2, c: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;a, ...param&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);    <span class="comment">//1</span></span><br><span class="line">  <span class="built_in">console</span>.log(param) <span class="comment">//&#123;b: 2, c: 3&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式命名捕获组"><a href="#正则表达式命名捕获组" class="headerlink" title="正则表达式命名捕获组"></a>正则表达式命名捕获组</h3><h4 id="编号的捕获组"><a href="#编号的捕获组" class="headerlink" title="编号的捕获组"></a>编号的捕获组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正则表达式命名捕获组</span></span><br><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/([0-9]&#123;4&#125;)-([0-9]&#123;2&#125;)-([0-9]&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj[<span class="number">1</span>]; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj[<span class="number">2</span>]; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj[<span class="number">3</span>]; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
<p>通过数字引用捕获组有几个缺点：</p>
<ul>
<li>找到捕获组的数量是一件麻烦事：必须使用括号。</li>
<li>如果要了解组的用途，则需要查看正则表达式。</li>
<li>如果更改捕获组的顺序，则还必须更改匹配代码。</li>
</ul>
<h4 id="命名的捕获组"><a href="#命名的捕获组" class="headerlink" title="命名的捕获组"></a>命名的捕获组</h4><p>ES9中可以通过名称来识别捕获组：<code>(?&lt;year&gt;[0-9]{4})</code></p>
<p>在这里，我们用名称标记了前一个捕获组year。该名称必须是合法的JavaScript标识符（认为变量名称或属性名称）。匹配后，您可以通过访问捕获的字符串matchObj.groups.year来访问。</p>
<p>让我们重写前面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj.groups.year; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj.groups.month; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj.groups.day; <span class="comment">// 31</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用解构语法更为简便</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">groups</span>: &#123;day, year&#125;&#125; = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(year); <span class="comment">// 1999</span></span><br><span class="line"><span class="built_in">console</span>.log(day); <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
<p>可以发现，命名捕获组有以下优点：</p>
<ul>
<li>找到捕获组的“ID”更容易。</li>
<li>匹配代码变为自描述性的，因为捕获组的ID描述了正在捕获的内容。</li>
<li>如果更改捕获组的顺序，则无需更改匹配代码。</li>
<li>捕获组的名称也使正则表达式更容易理解，因为您可以直接看到每个组的用途。</li>
</ul>
<h3 id="正则表达式-Unicode-转义"><a href="#正则表达式-Unicode-转义" class="headerlink" title="正则表达式 Unicode 转义"></a>正则表达式 Unicode 转义</h3><p>该特性允许您使用<code>\p{}</code>通过提及大括号内的Unicode字符属性来匹配字符,在正则表达式中使用标记 <code>u</code> (unicode) 设置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/^\p&#123;White_Space&#125;+$/u.test(<span class="string">'\t \n\r'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">/^\p&#123;Script=Greek&#125;+$/u.test(<span class="string">'μετά'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="新方法匹配中文字符"><a href="#新方法匹配中文字符" class="headerlink" title="新方法匹配中文字符"></a>新方法匹配中文字符</h4><p>由于在Unicode里面，中文字符对应的Unicode Script是<strong>Han</strong>，于是我们就可以用这个reg来匹配中文：</p>
<p><code>/\p{Script=Han}/u</code></p>
<p>这样我们就可以不用记忆繁琐又不好记的<code>/[\u4e00-\u9fa5]/</code>了，况且这个表达式已经有些年头了，说实话，后来又新增的属性为Han的字符并不在这个范围内，因此这个有年头reg并不一定好使。</p>
<p>我随便从网上找了一个Unicode8.0添加的中文字符“𬬭”,我测了一下两种reg的兼容性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">oldReg=<span class="regexp">/[\u4e00-\u9fa5]/</span></span><br><span class="line">newReg=<span class="regexp">/\p&#123;Script=Han&#125;/u</span></span><br><span class="line"></span><br><span class="line">oldReg.test(<span class="string">'abc'</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">newReg.test(<span class="string">'abc'</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">oldReg.test(<span class="string">'地平线'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">newReg.test(<span class="string">'地平线'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">oldReg.test(<span class="string">'𬬭'</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">newReg.test(<span class="string">'𬬭'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><a href="http://www.unicode.org/charts/PDF/U4E00.pdf" target="_blank" rel="noopener">http://www.unicode.org/charts/PDF/U4E00.pdf</a></p>
<p>可以参考一下这个PDF，是Unicode的汉字全集，从524页9FA6至526页（最后一页）用旧匹配方式都无法生效。</p>
<p><img src="/2018/11/27/细解JavaScript-ES7-ES8-ES9-新特性/Unicode.png" alt="Unicode"></p>
<h4 id="一些对于Unicode的科普"><a href="#一些对于Unicode的科普" class="headerlink" title="一些对于Unicode的科普"></a>一些对于Unicode的科普</h4><ul>
<li><p>Name：唯一名称，由大写字母，数字，连字符和空格组成。例如：</p>
<ul>
<li>A： Name = LATIN CAPITAL LETTER A</li>
<li>😀： Name = GRINNING FACE</li>
</ul>
</li>
<li><p>General_Category：对字符进行分类。例如：</p>
<ul>
<li>X： General_Category = Lowercase_Letter</li>
<li>$： General_Category = Currency_Symbol</li>
</ul>
</li>
<li><p>White_Space：用于标记不可见的间距字符，例如空格，制表符和换行符。例如：</p>
<ul>
<li>\ T： White_Space = True</li>
<li>π： White_Space = False</li>
</ul>
</li>
<li><p>Age：引入字符的Unicode标准版本。例如：欧元符号€在Unicode标准的2.1版中添加。</p>
<ul>
<li>€： Age = 2.1</li>
</ul>
</li>
<li><p>Script：是一个或多个书写系统使用的字符集合。</p>
<ul>
<li>有些脚本支持多种写入系统。例如，拉丁文脚本支持英语，法语，德语，拉丁语等书写系统。</li>
<li>某些语言可以用多个脚本支持的多个备用写入系统编写。例如，土耳其语在20世纪初转换为拉丁文字之前使用了阿拉伯文字。</li>
<li>例子：<ul>
<li>α： Script = Greek</li>
<li>Д： Script = Cyrillic</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="正则表达式的Unicode属性转义"><a href="#正则表达式的Unicode属性转义" class="headerlink" title="正则表达式的Unicode属性转义"></a>正则表达式的Unicode属性转义</h4><ul>
<li><p>匹配其属性prop具有值的所有字符value：</p>
<p>  <code>\p{prop=value}</code></p>
</li>
<li><p>匹配所有没有属性prop值的字符value：</p>
<p>  <code>\P{prop=value}</code></p>
</li>
<li><p>匹配二进制属性bin_prop为True的所有字符：</p>
<p>  <code>\p{bin_prop}</code></p>
</li>
<li><p>匹配二进制属性bin_prop为False的所有字符：</p>
<p>  <code>\P{bin_prop}</code></p>
</li>
<li><p>匹配空格：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\p&#123;White_Space&#125;+$/u.test(<span class="string">'\t \n\r'</span>)</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>匹配字母：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\p&#123;Letter&#125;+$/u.test(<span class="string">'πüé'</span>)</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>匹配希腊字母：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\p&#123;Script=Greek&#125;+$/u.test(<span class="string">'μετά'</span>)</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>匹配拉丁字母：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\p&#123;Script=Latin&#125;+$/u.test(<span class="string">'Grüße'</span>)</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="正则表达式反向断言"><a href="#正则表达式反向断言" class="headerlink" title="正则表达式反向断言"></a>正则表达式反向断言</h3><p>先来看下正则表达式先行断言是什么：</p>
<p>如获取货币的符号<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> noReLookahead = <span class="regexp">/\D(\d+)/</span>,</span><br><span class="line">      reLookahead = <span class="regexp">/\D(?=\d+)/</span>,</span><br><span class="line">      match1 = noReLookahead.exec(<span class="string">'$123.45'</span>),</span><br><span class="line">      match2 = reLookahead.exec(<span class="string">'$123.45'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match1[<span class="number">0</span>]); <span class="comment">// $123   </span></span><br><span class="line"><span class="built_in">console</span>.log(match2[<span class="number">0</span>]); <span class="comment">// $</span></span><br></pre></td></tr></table></figure></p>
<p>在ES9中可以允许反向断言：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reLookahead = <span class="regexp">/(?&lt;=\D)[\d\.]+/</span>;</span><br><span class="line">      match = reLookahead.exec(<span class="string">'$123.45'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match[<span class="number">0</span>]); <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure>
<p>使用?&lt;=进行反向断言，可以使用反向断言获取货币的价格，而忽略货币符号。</p>
<h3 id="正则表达式dotAll模式"><a href="#正则表达式dotAll模式" class="headerlink" title="正则表达式dotAll模式"></a>正则表达式dotAll模式</h3><p>正则表达式中点.匹配除回车外的任何单字符，标记s改变这种行为，允许行终止符的出现，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/hello.world/.test(<span class="string">'hello\nworld'</span>);  <span class="comment">// false</span></span><br><span class="line">/hello.world/s.test(<span class="string">'hello\nworld'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p>这个基本没什么好讲的，看名字就能看懂了。其用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">  .finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure>
<p>finally的回调总会被执行。</p>
<h3 id="模板字符串修改"><a href="#模板字符串修改" class="headerlink" title="模板字符串修改"></a>模板字符串修改</h3><p>ES2018 移除对 ECMAScript 在带标签的模版字符串中转义序列的语法限制。<br>之前，\u开始一个 unicode 转义，\x开始一个十六进制转义，\后跟一个数字开始一个八进制转义。这使得创建特定的字符串变得不可能，例如Windows文件路径 C:\uuu\xxx\111。</p>
<p>要取消转义序列的语法限制，可在模板字符串之前使用标记函数String.raw:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`\u&#123;54&#125;`</span></span><br><span class="line"><span class="comment">// "T"</span></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`\u&#123;54&#125;`</span></span><br><span class="line"><span class="comment">// "\u&#123;54&#125;"</span></span><br></pre></td></tr></table></figure>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>ECMAScript的演化不会停止，但是我们完全没必要害怕。除了ES6这个史无前例的版本带来了海量的信息和知识点以外，之后每年一发的版本都仅仅带有少量的增量更新，一年更新的东西花半个小时就能搞懂了，完全没必要畏惧。</p>
<p>Stay hungry. Stay foolish.</p>

  </section>

  <section class="post-comments">
    <div id="container"></div>
    <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
    <script src="https://www.wenjunjiang.win/js/gitment.js"></script>
    <script>
        var gitment = new Gitment({
            id: '细解JavaScript ES7 ES8 ES9 新特性', //github限制label长度不得超过50，修改label为中文名节省空间
            owner: 'tuobaye0711',
            repo: 'tuobaye0711.github.io',
            oauth: {
                client_id: '7c63ec766ab0084a9849',
                client_secret: 'e0bfadcadf48977a1a9b8b083de499d311a8dcfe',
            },
        })
        gitment.render('container')
    </script>
</section>


</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2016-2018. |  <a href="https://tuobaye0711.github.io/">拓跋的前端客栈</a>给您敬茶 |  主题基于<a href="https://github.com/someus/huno">Huno</a>改写 | <span>Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span> | <span id="busuanzi_container_site_uv" style="font-size: 0.8em">
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
    </span>
    </span>

</footer>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript">
        $(document).ready(function(){
            MathJax.Hub.Config({
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]}
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
