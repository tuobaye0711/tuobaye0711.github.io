<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>拓跋的前端客栈</title>
  
  <subtitle>江湖的尽头是否只剩孤独</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tuobaye0711.github.io/"/>
  <updated>2020-02-06T03:21:22.090Z</updated>
  <id>https://tuobaye0711.github.io/</id>
  
  <author>
    <name>zhleven</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从零开始开发一个Node交互式命令行应用</title>
    <link href="https://tuobaye0711.github.io/2018/12/03/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AANode%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8/"/>
    <id>https://tuobaye0711.github.io/2018/12/03/从零开始开发一个Node交互式命令行应用/</id>
    <published>2018-12-03T11:10:58.000Z</published>
    <updated>2020-02-06T03:21:22.090Z</updated>
    
    <content type="html"><![CDATA[<p>对于大多数前端开发者而言，谈到命令行工具，大家肯定都用过。但是谈到开发命令行工具，估计就没几人有了解了。本文旨在用最短的时间内，帮您开发一个实用（斜眼笑）的图片爬虫命令行应用。</p><h2 id="Puppeteer-简介"><a href="#Puppeteer-简介" class="headerlink" title="Puppeteer 简介"></a>Puppeteer 简介</h2><h3 id="什么是-Puppeteer"><a href="#什么是-Puppeteer" class="headerlink" title="什么是 Puppeteer?"></a>什么是 Puppeteer?</h3><p>Puppeteer 是 Google Chrome 团队官方的无界面（Headless）Chrome 工具。Chrome 作为浏览器市场的领头羊，Chrome Headless  将成为 web 应用   自动化测试   的行业标杆。所以我们很有必要来了解一下它。</p><p><img src="/2018/12/03/从零开始开发一个Node交互式命令行应用/puppeteer.png" alt="puppeteer"></p><h3 id="Puppeteer-可以做什么？"><a href="#Puppeteer-可以做什么？" class="headerlink" title="Puppeteer 可以做什么？"></a>Puppeteer 可以做什么？</h3><p>Puppeteer 可以做的事情有很多，包括但不限于：</p><ul><li>利用网页生成 PDF、图片</li><li>可以从网站抓取内容</li><li>自动化表单提交、UI 测试、键盘输入等</li><li>帮你创建一个最新的自动化测试环境（chrome），可以直接在此运行测试用例</li><li>捕获站点的时间线，以便追踪你的网站，帮助分析网站性能问题</li></ul><h3 id="Puppeteer-有什么优势？"><a href="#Puppeteer-有什么优势？" class="headerlink" title="Puppeteer 有什么优势？"></a>Puppeteer 有什么优势？</h3><ul><li>相对于真实浏览器而言，少了加载 css，js 以及渲染页面的工作。无头浏览器要比真实浏览器快的多。</li><li>可以在无界面的服务器或 CI 上运行，减少了外界的干扰，更稳定。</li><li>在一台机器上可以模拟运行多个无头浏览器，方便进行并发运行。</li></ul><h3 id="如何安装-Puppeteer？"><a href="#如何安装-Puppeteer？" class="headerlink" title="如何安装 Puppeteer？"></a>如何安装 Puppeteer？</h3><p>安装  Puppeteer  很简单，如下：<br><code>npm i --save puppeteer</code><br>or<br><code>yarn add puppeteer</code></p><p>需要注意的是，由于用到了 ES7 的  async/await  语法 ，node  版本最好是 v7.6.0 或以上。</p><h3 id="如何使用-Puppeteer？"><a href="#如何使用-Puppeteer？" class="headerlink" title="如何使用 Puppeteer？"></a>如何使用 Puppeteer？</h3><p>由于本文不是专门讲 Puppeteer 的文章，故这部分暂且略过，大家可以去看下面的链接学习。</p><p><a href="https://github.com/GoogleChrome/puppeteer" target="_blank" rel="noopener">Puppeteer Github</a></p><p><a href="https://github.com/GoogleChrome/puppeteer/blob/v1.8.0/docs/api.md#overview" target="_blank" rel="noopener">Puppeteer Api Doc</a></p><p><a href="https://zhaoqize.github.io/puppeteer-api-zh_CN/#/" target="_blank" rel="noopener">Puppeteer 中文 Api Doc</a></p><p>说了这么多，Puppeteer 与我们要开发的命令行应用有什么关系呢？我们准备制作一个抓图命令行工具，不使用传统的请求式爬虫，我们使用 Puppeteer 这种无头浏览器，从 DOM 里抓图，这样能有效规避部分爬虫防御手段。</p><h2 id="Puppeteer-简单应用"><a href="#Puppeteer-简单应用" class="headerlink" title="Puppeteer 简单应用"></a>Puppeteer 简单应用</h2><h3 id="case-1-屏幕截图"><a href="#case-1-屏幕截图" class="headerlink" title="case 1. 屏幕截图"></a>case 1. 屏幕截图</h3><p>直接上代码，很好理解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">"puppeteer"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getScreenShot = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123; <span class="attr">headless</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">"https://baidu.com"</span>);</span><br><span class="line">  <span class="keyword">await</span> page.screenshot(&#123; <span class="attr">path</span>: <span class="string">"baidu.png"</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getScreenShot();</span><br></pre></td></tr></table></figure><p>这段代码的意思就是以 headless（无头）模式打开浏览器，然后打开一个新标签页，跳转到百度网址， 并且进行屏幕截图，保存为 baidu.png 为名的图片，最后关闭浏览器。</p><p>执行结果如下。</p><p><img src="/2018/12/03/从零开始开发一个Node交互式命令行应用/baidu.jpg" alt="baidu"></p><h3 id="case-2-抓取网站信息"><a href="#case-2-抓取网站信息" class="headerlink" title="case 2. 抓取网站信息"></a>case 2. 抓取网站信息</h3><p>接下来学习如何用 Puppeteer 抓取网站信息了。</p><p>这次我们来抓取 jd 书单信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// book info spider</span></span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">"puppeteer"</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> spider = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">"https://search.jd.com/Search?keyword=javascript"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> elements = <span class="built_in">document</span>.querySelectorAll(<span class="string">".gl-item"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> data = [...elements].map(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        name: i.querySelector(<span class="string">".p-name em"</span>).innerText,</span><br><span class="line">        description: i.querySelector(<span class="string">".p-name i"</span>).innerText,</span><br><span class="line">        price: i.querySelector(<span class="string">".p-price"</span>).innerText,</span><br><span class="line">        shop: i.querySelector(<span class="string">".p-shopnum"</span>).innerText,</span><br><span class="line">        url: i.querySelector(<span class="string">".p-img a"</span>).href</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> data; <span class="comment">// 返回数据</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  browser.close();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">spider().then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  fs.writeFile(<span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/javascript.json`</span>, <span class="built_in">JSON</span>.stringify(value), err =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"file saved!"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// Success!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们做的就是跳转到关键字是 javascript 的页面，然后对页面的 dom 结构进行分析，找到图书列表所对应的书名、描述、价格、出版社、网页链接信息，然后把数据写入到 javascript.json 文件里去，方便我们保存浏览。</p><p>逻辑很简单。这已经是一个爬虫的雏形了，最后得到如下图所示的 json 文件，非常给力。</p><p><img src="/2018/12/03/从零开始开发一个Node交互式命令行应用/javascript.json.png" alt="javascript.json"></p><h3 id="case-3-图片爬虫"><a href="#case-3-图片爬虫" class="headerlink" title="case 3. 图片爬虫"></a>case 3. 图片爬虫</h3><p>图片爬虫，这就是我们要做的命令行应用的主题了。</p><p>一个最基本的思路是这样的：</p><p>打开浏览器 —&gt; 跳转到百度图片 —&gt; 获取 input 框的焦点 —&gt; 输入 keywords —&gt; 点击搜索按钮 —&gt; 跳转至结果列表页 —&gt; 下拉到底部 —&gt; 操作 dom，获取所有图片的 src 备用 —&gt; 根据 src 将对应图片保存到本地 —&gt; 关闭浏览器</p><p>代码实现之：</p><p>首先是浏览器操作部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(); <span class="comment">// 打开浏览器</span></span><br><span class="line"><span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage(); <span class="comment">// 打开新tab页</span></span><br><span class="line"><span class="keyword">await</span> page.goto(<span class="string">"https://image.baidu.com"</span>); <span class="comment">// 跳转到百度图片</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"go to https://image.baidu.com"</span>); <span class="comment">// 获取input框的焦点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> page.focus(<span class="string">"#kw"</span>); <span class="comment">// 把焦点定位到搜索input框</span></span><br><span class="line"><span class="keyword">await</span> page.keyboard.sendCharacter(<span class="string">"猫咪"</span>); <span class="comment">// 输入关键字</span></span><br><span class="line"><span class="keyword">await</span> page.click(<span class="string">".s_search"</span>); <span class="comment">// 点击搜索按钮</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"go to search list"</span>); <span class="comment">// 提示跳转到搜索列表页</span></span><br></pre></td></tr></table></figure><p>然后是图片处理部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">page.on(<span class="string">"load"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> autoScroll(page); <span class="comment">// 向下滚动加载图片</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"page loading done, start fetch..."</span>);</span><br><span class="line">  <span class="keyword">const</span> srcs = <span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> images = <span class="built_in">document</span>.querySelectorAll(<span class="string">"img.main_img"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.map.call(images, img =&gt; img.src);</span><br><span class="line">  &#125;); <span class="comment">// 获取所有img的src</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`get <span class="subst">$&#123;srcs.length&#125;</span> images, start download`</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; srcs.length; i++) &#123;</span><br><span class="line">    <span class="keyword">await</span> convert2Img(srcs[i], target);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`finished <span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>/<span class="subst">$&#123;srcs.length&#125;</span> images`</span>);</span><br><span class="line">  &#125; <span class="comment">// 保存图片</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`job finished!`</span>);</span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>因为百度图片是往下滚动就可以继续懒加载。因此，我们想要加载更多图片，可以先往下滚动一会儿。然后通过分析 dom 结构来获取列表里所有图片的 src，最后进行下载。</p><p>执行以下，就能得到一系列猫咪的图片：</p><p><img src="/2018/12/03/从零开始开发一个Node交互式命令行应用/cat.jpg" alt="cat"></p><p>图片下载的地方只写了主函数，更详细的代码可以去参见<a href="https://github.com/tuobaye0711/img-spd/blob/master/demo4/baidu.js" target="_blank" rel="noopener">github</a>.</p><p>至此，我们用 Node 和 Puppeteer 开发出了一个最基本的图片爬虫工具。</p><h2 id="如何优化？"><a href="#如何优化？" class="headerlink" title="如何优化？"></a>如何优化？</h2><p>这个图片爬虫工具目前还有点 low 啊，我们的目标是要开发一个交互式的命令行应用，肯定不能止于此。有哪些可以进一步优化的点呢？经过简单的思考，我列了一下：</p><ul><li>下载图片的内容可以自定义</li><li>可以支持用户选择图片下载张数</li><li>支持命令行传参</li><li>支持命令行交互</li><li>交互界面美观</li><li>支持双击直接运行</li><li>支持全局命令行调用</li></ul><h2 id="使用-commander-js-支持命令行传参"><a href="#使用-commander-js-支持命令行传参" class="headerlink" title="使用 commander.js 支持命令行传参"></a>使用 commander.js 支持命令行传参</h2><p>Commander 是一款重量轻，表现力和强大的命令行框架。提供了用户命令行输入和参数解析强大功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> program = <span class="built_in">require</span>(<span class="string">"commander"</span>);</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">  .version(<span class="string">"0.0.1"</span>)</span><br><span class="line">  .description(<span class="string">"a test cli program"</span>)</span><br><span class="line">  .option(<span class="string">"-n, --name &lt;name&gt;"</span>, <span class="string">"your name"</span>, <span class="string">"zhl"</span>)</span><br><span class="line">  .option(<span class="string">"-a, --age &lt;age&gt;"</span>, <span class="string">"your age"</span>, <span class="string">"22"</span>)</span><br><span class="line">  .option(<span class="string">"-e, --enjoy [enjoy]"</span>)</span><br><span class="line">  .action(<span class="function"><span class="params">option</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'name: '</span>, option.name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'age: '</span>, option.age);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'enjoy: '</span>, option.enjoy);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">program.parse(process.argv);</span><br></pre></td></tr></table></figure><p>Commander十分容易上手，上面这一段代码仅用了寥寥数行，就定义了一个命令行的输入与输出。其中：</p><ul><li>version 定义版本号</li><li>description 定义描述信息</li><li>option 定义输入选项，传3个参数，如<code>option(&quot;-n, --name &lt;name&gt;&quot;, &quot;your name&quot;, &quot;GK&quot;)</code>，第一项是传参的值，-n是简写形式，–name是全称形式， <name>表示输入的参数，&lt;&gt;是必填项，如果是[]，则是选填项。第二项“your name”是求助help时的提示信息，告诉用户应该输入的内容，最后一项”GK”是默认值。</name></li><li>action 定义执行的操作，是一个回调函数，入参是前文输入的option选项，如果没有输入option，则使用定义的默认值。</li></ul><p>要查询更详细的api，请参考<a href="http://tj.github.io/commander.js/" target="_blank" rel="noopener">Commander Api文档</a>。</p><p>执行一下上述脚本，可以得到：</p><p><img src="/2018/12/03/从零开始开发一个Node交互式命令行应用/commander.png" alt="commander.png"></p><p>这样命令行就可以做到简单的交互效果了。但是有没有觉得不够好看呢，别急，继续往下看。</p><h2 id="使用inquirer制作可交互命令行应用"><a href="#使用inquirer制作可交互命令行应用" class="headerlink" title="使用inquirer制作可交互命令行应用"></a>使用inquirer制作可交互命令行应用</h2><p>inquirer可以为Node制作可嵌入式的美观的命令行界面。</p><p>可以提供问答式的命令输入：</p><p><img src="/2018/12/03/从零开始开发一个Node交互式命令行应用/inquirer1.png" alt="inquirer1"></p><p>可以提供多种形式的选择界面：</p><p><img src="/2018/12/03/从零开始开发一个Node交互式命令行应用/inquirer2.png" alt="inquirer2"><br><img src="/2018/12/03/从零开始开发一个Node交互式命令行应用/inquirer3.png" alt="inquirer3"></p><p>可以对输入信息进行校验：<br><img src="/2018/12/03/从零开始开发一个Node交互式命令行应用/inquirer4.png" alt="inquirer4"></p><p>最后可以对输入信息进行处理：<br><img src="/2018/12/03/从零开始开发一个Node交互式命令行应用/inquirer5.png" alt="inquirer5"></p><p>上面的例子是inquirer的官方例子，可以参考<a href="https://github.com/SBoudrias/Inquirer.js/blob/master/packages/inquirer/examples/pizza.js" target="_blank" rel="noopener">pizza.js</a></p><p>inquirer的文档可以查看<a href="https://github.com/SBoudrias/Inquirer.js#documentation" target="_blank" rel="noopener">inquirer documents</a></p><p>有了inquirer，我们就可以制作更为精美的交互式命令行工具了。</p><h2 id="使用-chalk-js来让交互界面更美观"><a href="#使用-chalk-js来让交互界面更美观" class="headerlink" title="使用 chalk.js来让交互界面更美观"></a>使用 chalk.js来让交互界面更美观</h2><p><img src="/2018/12/03/从零开始开发一个Node交互式命令行应用/chalk.png" alt="chalk.js"></p><p>chalk的语法非常简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</span><br><span class="line"><span class="keyword">const</span> log = <span class="built_in">console</span>.log;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Combine styled and normal strings</span></span><br><span class="line">log(chalk.blue(<span class="string">'Hello'</span>) + <span class="string">' World'</span> + chalk.red(<span class="string">'!'</span>));</span><br><span class="line"><span class="comment">// Compose multiple styles using the chainable API</span></span><br><span class="line">log(chalk.blue.bgRed.bold(<span class="string">'Hello world!'</span>));</span><br><span class="line"><span class="comment">// Pass in multiple arguments</span></span><br><span class="line">log(chalk.blue(<span class="string">'Hello'</span>, <span class="string">'World!'</span>, <span class="string">'Foo'</span>, <span class="string">'bar'</span>, <span class="string">'biz'</span>, <span class="string">'baz'</span>));</span><br><span class="line"><span class="comment">// Nest styles</span></span><br><span class="line">log(chalk.red(<span class="string">'Hello'</span>, chalk.underline.bgBlue(<span class="string">'world'</span>) + <span class="string">'!'</span>));</span><br><span class="line"><span class="comment">// Nest styles of the same type even (color, underline, background)</span></span><br><span class="line">log(chalk.green(</span><br><span class="line">  <span class="string">'I am a green line '</span> +</span><br><span class="line">  chalk.blue.underline.bold(<span class="string">'with a blue substring'</span>) +</span><br><span class="line">  <span class="string">' that becomes green again!'</span></span><br><span class="line">));</span><br></pre></td></tr></table></figure><p>可以输出如下信息，一看便懂：</p><p><img src="/2018/12/03/从零开始开发一个Node交互式命令行应用/chalk2.png" alt="chalk2"></p><h2 id="再让我们做点有意思的事情…"><a href="#再让我们做点有意思的事情…" class="headerlink" title="再让我们做点有意思的事情…"></a>再让我们做点有意思的事情…</h2><p>想必有人看到过下面知乎的控制台效果，既然要做点有意思的事情，今天我们不妨也把这种效果加到命令行程序里面，提升一下逼格。</p><p><img src="/2018/12/03/从零开始开发一个Node交互式命令行应用/zhihu.png" alt="zhihu"></p><p>首先我们准备一副ASCII码用来打印，各位可以自行搜索text转ASCII，网上的转化方案不要太多。我们准备制作的命令行image spider就制作一个IMG SPD的ASCII码字符串吧~</p><p>经过挑选，效果如图:</p><p><img src="/2018/12/03/从零开始开发一个Node交互式命令行应用/imgspd.png" alt="imgspd"></p><p>这种复杂的字符串怎么打印出来呢？直接保存为string一定是不行的，格式会乱的一塌糊涂。</p><p>想要能完整的打印出格式来，有一个取巧的方法，以注释的形式打印出来。什么能保存注释呢?~~ function。</p><p>所以事情就简单到了打印一个function。但是直接打印函数还是不行的，这时候就用到了可以怼天怼地的toString()方法，我们只需要把注释中间的部分用正则匹配出来就行了，easy~</p><p><img src="/2018/12/03/从零开始开发一个Node交互式命令行应用/imgspd2.png" alt="imgspd2"></p><p>最后看一看效果，铛铛铛铛~</p><p><img src="/2018/12/03/从零开始开发一个Node交互式命令行应用/imgspd3.png" alt="imgspd3"></p><h2 id="支持双击运行"><a href="#支持双击运行" class="headerlink" title="支持双击运行"></a>支持双击运行</h2><p>这里使用一种叫做Shebang的技术。</p><p>Shebang（也称为 Hashbang ）是一个由#和！构成的字符序列 #! ，其出现在文本文件的第一行的前两个字符。 在文件中存在 Shebang 的情况下，类 Unix 操作系统的程序加载器会分析 Shebang 后的内容，将这些内容作为解释器指令，并调用该指令，并将载有 Shebang 的文件路径作为该解释器的参数。</p><p>node下我们使用#! /usr/bin/env node即可</p><p>这时候我们便可以取消文件的扩展名.js了。</p><h2 id="加入环境变量，支持全局调用"><a href="#加入环境变量，支持全局调用" class="headerlink" title="加入环境变量，支持全局调用"></a>加入环境变量，支持全局调用</h2><p>package.json里面配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"bin"</span>: &#123;</span><br><span class="line">  <span class="string">"img-spd"</span>: <span class="string">"app"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>执行npm link，它将会把img-spd这个字段复制到npm的全局模块安装文件夹node_modules内，并创建符号链接（symbolic link，软链接），也就是将 app 的路径加入环境变量 PATH。</p><p>这时，在任意目录下，直接命令行输入img-spd即可运行此命令行</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>至此，要改进的地方已经全部修改完毕，快来看看我们的成品吧~</p><p><img src="/2018/12/03/从零开始开发一个Node交互式命令行应用/imgspd4.png" alt="imgspd4"></p><p>看着一整个文件夹的gakki，感觉满满的幸福要溢出来了</p><p><img src="/2018/12/03/从零开始开发一个Node交互式命令行应用/gakki.png" alt="gakki"></p><p>最后用动图来展示一下：</p><p><img src="/2018/12/03/从零开始开发一个Node交互式命令行应用/img-spd.gif" alt="img-spd"></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/tuobaye0711/img-spd" target="_blank" rel="noopener">项目地址</a></p><h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g img-spd</span><br></pre></td></tr></table></figure><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img-spd</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Usage: img-spd [options]</span><br><span class="line"></span><br><span class="line">img-spd is a spider get images from image.baidu.com</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -v --version               output the version number</span><br><span class="line">  -k, --key [key]            input the image keywords to download</span><br><span class="line">  -i, --interval [interval]  input the operation interval(ms,default 200)</span><br><span class="line">  -n, --number [number]      input the operation interval(ms,default 200)</span><br><span class="line">  -m, --headless [headless]  choose whether the program is running in headless mode</span><br><span class="line">  -h, --help                 output usage information</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      对于大多数前端开发者而言，谈到命令行工具，大家肯定都用过。但是谈到开发命令行工具，估计就没几人有了解了。本文旨在用最短的时间内，帮您开发一个实用（斜眼笑）的命令行应用。
    
    </summary>
    
    
      <category term="Node.js JavaScript" scheme="https://tuobaye0711.github.io/tags/Node-js-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>细解JavaScript ES7 ES8 ES9 新特性</title>
    <link href="https://tuobaye0711.github.io/2018/11/27/%E7%BB%86%E8%A7%A3JavaScript-ES7-ES8-ES9-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://tuobaye0711.github.io/2018/11/27/细解JavaScript-ES7-ES8-ES9-新特性/</id>
    <published>2018-11-27T11:05:32.000Z</published>
    <updated>2020-02-06T03:32:00.933Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/11/27/细解JavaScript-ES7-ES8-ES9-新特性/es_16_17_18.png" alt="es_16_17_18"></p><p>题记：本文提供了一个在线PPT版本，方便您浏览 <a href="https://tuobaye.com/demo/es7_es8_es9/" target="_blank" rel="noopener">细解JAVASCRIPT ES7 ES8 ES9 新特性 在线PPT ver</a></p><p>本文的大部分内容译自作者Axel Rauschmayer博士的网站，想了解更多关于作者的信息，可以浏览<a href="http://exploringjs.com/" target="_blank" rel="noopener">Exploring JS: JavaScript books for programmers</a></p><h2 id="那些与ECMAScript有关的事情"><a href="#那些与ECMAScript有关的事情" class="headerlink" title="那些与ECMAScript有关的事情"></a>那些与ECMAScript有关的事情</h2><h3 id="谁在设计ECMAScript"><a href="#谁在设计ECMAScript" class="headerlink" title="谁在设计ECMAScript?"></a>谁在设计ECMAScript?</h3><p>TC39 (Technical Committee 39)。</p><p>TC39 是推进 JavaScript 发展的委员会。其会员都是公司（其中主要是浏览器厂商）。TC39 定期召开会议，会议由会员公司的代表与特邀专家出席。会议纪录都可在网上查看，可以让你对 TC39 如何工作有一个清晰的概念。</p><p>很有意思的是，TC39 实行的是协商一致的原则：通过一项决议必须得到每一位会员（公司代表）的赞成。</p><h3 id="ECMAScript的发布周期"><a href="#ECMAScript的发布周期" class="headerlink" title="ECMAScript的发布周期"></a>ECMAScript的发布周期</h3><p>在2015年发布的 ECMAScript（ES6）新增内容很多，在 ES5 发布近 6 年（2009-11 至 2015-6）之后才将其标准化。两个发布版本之间时间跨度如此之大主要有两大原因：</p><ul><li>比新版率先完成的特性，必须等待新版的完成才能发布。</li><li>那些需要花长时间完成的特性，也顶着很大的压力被纳入这一版本，因为如果推迟到下一版本发布意味着又要等很久，这种特性也会推迟新的发布版本。</li></ul><p>因此，从 ECMAScript 2016（ES7）开始，版本发布变得更加频繁，每年发布一个新版本，这么一来新增内容也会更小。新版本将会包含每年截止时间之前完成的所有特性。</p><h3 id="ECMAScript的发布流程"><a href="#ECMAScript的发布流程" class="headerlink" title="ECMAScript的发布流程"></a>ECMAScript的发布流程</h3><p>每个 ECMAScript 特性的建议将会从阶段 0 开始， 然后经过下列几个成熟阶段。其中从一个阶段到下一个阶段必须经过 TC39 的批准。</p><ol><li><p>stage-0 - Strawman: just an idea, possible Babel plugin.<br>任何讨论、想法、改变或者还没加到提案的特性都在这个阶段。只有TC39成员可以提交。</p><p>当前的stage 0列表可以查看这里 –&gt; <a href="https://github.com/tc39/proposals/blob/master/stage-0-proposals.md" target="_blank" rel="noopener">Stage 0 Proposals</a></p></li><li><p>stage-1 - Proposal: this is worth working on.</p><p><strong>什么是 Proposal？</strong>一份新特性的正式建议文档。提案必须指明此建议的潜在问题，例如与其他特性之间的关联，实现难点等。</p></li><li><p>stage-2 - Draft: initial spec.</p><p><strong>什么是 Draft？</strong>草案是规范的第一个版本。其与最终标准中包含的特性不会有太大差别。</p><p>草案之后，原则上只接受增量修改。这个阶段开始实验如何实现，实现形式包括polyfill, 实现引擎（提供草案执行本地支持），或者编译转换（例如babel）</p></li><li><p>stage-3 - Candidate: complete spec and initial browser implementations.</p><p>候选阶段，获得具体实现和用户的反馈。此后，只有在实现和使用过程中出现了重大问题才会修改。至少要在一个浏览器中实现，提供polyfill或者babel插件。</p></li><li><p>stage-4 - Finished: will be added to the next yearly release.</p><p>已经准备就绪，该特性会出现在下个版本的ECMAScript规范之中。</p><p>当前的stage 1-3列表可以查看这里 –&gt; <a href="https://github.com/tc39/proposals" target="_blank" rel="noopener">ECMAScript proposals</a></p></li></ol><h3 id="已经正式发布的特性索引"><a href="#已经正式发布的特性索引" class="headerlink" title="已经正式发布的特性索引"></a>已经正式发布的特性索引</h3><table><thead><tr><th>Proposal</th><th>Author</th><th>Champion(s)</th><th>TC39 meeting notes</th><th>Expected Publication Year</th></tr></thead><tbody><tr><td><a href="https://github.com/tc39/Array.prototype.includes" target="_blank" rel="noopener"><code>Array.prototype.includes</code></a></td><td>Domenic Denicola</td><td>Domenic Denicola<br>Rick Waldron</td><td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es7/2015-11/nov-17.md#arrayprototypeincludes" target="_blank" rel="noopener">November 2015</a></td><td>2016</td></tr><tr><td><a href="https://github.com/rwaldron/exponentiation-operator" target="_blank" rel="noopener">Exponentiation operator</a></td><td>Rick Waldron</td><td>Rick Waldron</td><td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es7/2016-01/2016-01-28.md#5xviii-exponentiation-operator-rw" target="_blank" rel="noopener">January 2016</a></td><td>2016</td></tr><tr><td><a href="https://github.com/tc39/proposal-object-values-entries" target="_blank" rel="noopener"><code>Object.values</code>/<code>Object.entries</code></a></td><td>Jordan Harband</td><td>Jordan Harband</td><td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es7/2016-03/march-29.md#objectvalues--objectentries" target="_blank" rel="noopener">March 2016</a></td><td>2017</td></tr><tr><td><a href="https://github.com/tc39/proposal-string-pad-start-end" target="_blank" rel="noopener">String padding</a></td><td>Jordan Harband</td><td>Jordan Harband<br>Rick Waldron</td><td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es7/2016-05/may-25.md#stringprototypepadstartend-jhd" target="_blank" rel="noopener">May 2016</a></td><td>2017</td></tr><tr><td><a href="https://github.com/ljharb/proposal-object-getownpropertydescriptors" target="_blank" rel="noopener"><code>Object.getOwnPropertyDescriptors</code></a></td><td>Jordan Harband<br>Andrea Giammarchi</td><td>Jordan Harband<br>Andrea Giammarchi</td><td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es7/2016-05/may-25.md#objectgetownpropertydescriptors-jhd" target="_blank" rel="noopener">May 2016</a></td><td>2017</td></tr><tr><td><a href="https://github.com/tc39/proposal-trailing-function-commas" target="_blank" rel="noopener">Trailing commas in function parameter lists and calls</a></td><td>Jeff Morrison</td><td>Jeff Morrison</td><td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es7/2016-07/jul-26.md#9ie-trailing-commas-in-functions" target="_blank" rel="noopener">July 2016</a></td><td>2017</td></tr><tr><td><a href="https://github.com/tc39/ecmascript-asyncawait" target="_blank" rel="noopener">Async functions</a></td><td>Brian Terlson</td><td>Brian Terlson</td><td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es7/2016-07/jul-28.md#10iv-async-functions" target="_blank" rel="noopener">July 2016</a></td><td>2017</td></tr><tr><td><a href="https://github.com/tc39/ecmascript_sharedmem" target="_blank" rel="noopener">Shared memory and atomics</a></td><td>Lars T Hansen</td><td>Lars T Hansen</td><td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es7/2017-01/jan-24.md#13if-seeking-stage-4-for-sharedarraybuffer" target="_blank" rel="noopener">January 2017</a></td><td>2017</td></tr><tr><td><a href="https://github.com/tc39/proposal-template-literal-revision" target="_blank" rel="noopener">Lifting template literal restriction</a></td><td>Tim Disney</td><td>Tim Disney</td><td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es8/2017-03/mar-21.md#10ia-template-literal-updates" target="_blank" rel="noopener">March 2017</a></td><td>2018</td></tr><tr><td><a href="https://github.com/tc39/proposal-regexp-dotall-flag" target="_blank" rel="noopener"><code>s</code> (<code>dotAll</code>) flag for regular expressions</a></td><td>Mathias Bynens</td><td>Brian Terlson<br>Mathias Bynens</td><td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es8/2017-11/nov-28.md#9ie-regexp-dotall-status-update" target="_blank" rel="noopener">November 2017</a></td><td>2018</td></tr><tr><td><a href="https://github.com/tc39/proposal-regexp-named-groups" target="_blank" rel="noopener">RegExp named capture groups</a></td><td>Gorkem Yakin<br>Daniel Ehrenberg</td><td>Daniel Ehrenberg<br>Brian Terlson<br>Mathias Bynens</td><td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es8/2017-11/nov-28.md#9if-regexp-named-captures-status-update" target="_blank" rel="noopener">November 2017</a></td><td>2018</td></tr><tr><td><a href="https://github.com/tc39/proposal-object-rest-spread" target="_blank" rel="noopener">Rest/Spread Properties</a></td><td>Sebastian Markbåge</td><td>Sebastian Markbåge</td><td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es8/2018-01/jan-23.md#restspread-properties-for-stage-4" target="_blank" rel="noopener">January 2018</a></td><td>2018</td></tr><tr><td><a href="https://github.com/tc39/proposal-regexp-lookbehind" target="_blank" rel="noopener">RegExp Lookbehind Assertions</a></td><td>Gorkem Yakin<br>Nozomu Katō<br>Daniel Ehrenberg</td><td>Daniel Ehrenberg<br>Mathias Bynens</td><td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es8/2018-01/jan-23.md#conclusionresolution-16" target="_blank" rel="noopener">January 2018</a></td><td>2018</td></tr><tr><td><a href="https://github.com/tc39/proposal-regexp-unicode-property-escapes" target="_blank" rel="noopener">RegExp Unicode Property Escapes</a></td><td>Mathias Bynens</td><td>Brian Terlson<br>Daniel Ehrenberg<br>Mathias Bynens</td><td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es8/2018-01/jan-24.md#conclusionresolution-1" target="_blank" rel="noopener">January 2018</a></td><td>2018</td></tr><tr><td><a href="https://github.com/tc39/proposal-promise-finally" target="_blank" rel="noopener"><code>Promise.prototype.finally</code></a></td><td>Jordan Harband</td><td>Jordan Harband</td><td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es8/2018-01/jan-24.md#conclusionresolution-2" target="_blank" rel="noopener">January 2018</a></td><td>2018</td></tr><tr><td><a href="https://github.com/tc39/proposal-async-iteration" target="_blank" rel="noopener">Asynchronous Iteration</a></td><td>Domenic Denicola</td><td>Domenic Denicola</td><td><a href="https://github.com/rwaldron/tc39-notes/blob/master/es8/2018-01/jan-25.md#conclusionresolution" target="_blank" rel="noopener">January 2018</a></td><td>2018</td></tr><tr><td><a href="https://github.com/tc39/proposal-optional-catch-binding" target="_blank" rel="noopener">Optional <code>catch</code> binding</a></td><td>Michael Ficarra</td><td>Michael Ficarra</td><td>May 2018</td><td>2019</td></tr><tr><td><a href="https://github.com/tc39/proposal-json-superset" target="_blank" rel="noopener">JSON superset</a></td><td>Richard Gibson</td><td>Mark Miller<br>Mathias Bynens</td><td>May 2018</td><td>2019</td></tr></tbody></table><h2 id="ES7新特性（ECMAScript-2016）"><a href="#ES7新特性（ECMAScript-2016）" class="headerlink" title="ES7新特性（ECMAScript 2016）"></a>ES7新特性（ECMAScript 2016）</h2><p><img src="/2018/11/27/细解JavaScript-ES7-ES8-ES9-新特性/es2016.png" alt="ECMAScript 2016"></p><p>ES7在ES6的基础上主要添加了两项内容：</p><ul><li>Array.prototype.includes()方法</li><li>求幂运算符（**）</li></ul><h3 id="Array-prototype-includes-方法"><a href="#Array-prototype-includes-方法" class="headerlink" title="Array.prototype.includes()方法"></a>Array.prototype.includes()方法</h3><p>includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array.includes(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// expected output: true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pets = [<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'bat'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pets.includes(<span class="string">'cat'</span>));</span><br><span class="line"><span class="comment">// expected output: true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pets.includes(<span class="string">'at'</span>));</span><br><span class="line"><span class="comment">// expected output: false</span></span><br></pre></td></tr></table></figure><p>Array.prototype.includes()方法接收两个参数：</p><ul><li>要搜索的值</li><li>搜索的开始索引。</li></ul><p>当第二个参数被传入时，该方法会从索引处开始往后搜索（默认索引值为0）。若搜索值在数组中存在则返回true，否则返回false。 且看下面示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>].includes(<span class="string">'b'</span>)         <span class="comment">// true</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>].includes(<span class="string">'b'</span>, <span class="number">1</span>)      <span class="comment">// true</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>].includes(<span class="string">'b'</span>, <span class="number">2</span>)      <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>乍一看，includes的作用跟数组的indexOf重叠，为什么要特意增加这么一个api呢？主要区别有以下几点：</p><ul><li>返回值。看一个函数，先看他们的返回值。indexOf的返回数是值型的，includes的返回值是布尔型，所以在if条件判断的时候includes要简单得多，而indexOf 需要多写一个条件进行判断。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary = [<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (ary.indexOf(<span class="number">1</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"数组存在1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ary.includes(<span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"数组存在1"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>NaN的判断。如果数组中有NaN，你又正好需要判断数组是否有存在NaN，这时你使用indexOf是无法判断的，你必须使用includes这个方法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary1 = [<span class="literal">NaN</span>];</span><br><span class="line"><span class="built_in">console</span>.log(ary1.indexOf(<span class="literal">NaN</span>))<span class="comment">//-1</span></span><br><span class="line"><span class="built_in">console</span>.log(ary1.includes(<span class="literal">NaN</span>))<span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li>当数组的有空的值的时候，includes会认为空的值是undefined，而indexOf不会。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ary1.indexOf(<span class="literal">undefined</span>));<span class="comment">//-1</span></span><br><span class="line"><span class="built_in">console</span>.log(ary1.includes(<span class="literal">undefined</span>))<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="求幂运算符（-）"><a href="#求幂运算符（-）" class="headerlink" title="求幂运算符（**）"></a>求幂运算符（**）</h3><p>加/减法我们通常都是用其中缀形式，直观易懂。在ECMAScript2016中，我们可以使用<code>**</code>来替代Math.pow。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> ** <span class="number">3</span>           <span class="comment">// 64</span></span><br></pre></td></tr></table></figure><p>效果等同于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">4</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>值得一提的是，作为中缀运算符，**还支持以下操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">4</span>;</span><br><span class="line">n **= <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 64</span></span><br></pre></td></tr></table></figure><h2 id="ES8新特性（ECMAScript-2017）"><a href="#ES8新特性（ECMAScript-2017）" class="headerlink" title="ES8新特性（ECMAScript 2017）"></a>ES8新特性（ECMAScript 2017）</h2><p><img src="/2018/11/27/细解JavaScript-ES7-ES8-ES9-新特性/es2017.png" alt="ECMAScript 2017"></p><p>在2017年1月的TC39会议上，ECMAScript 2017的最后一个功能“Shared memory and atomics”推进到第4阶段。这意味着它的功能集现已完成。</p><p>ECMAScript 2017特性一览</p><p>主要新功能：</p><ul><li>异步函数 Async Functions（Brian Terlson）</li><li>共享内存和Atomics（Lars T. Hansen）</li></ul><p>次要新功能：</p><ul><li>Object.values / Object.entries（Jordan Harband）</li><li>String padding（Jordan Harband，Rick Waldron）</li><li>Object.getOwnPropertyDescriptors() （Jordan Harband，Andrea Giammarchi）</li><li>函数参数列表和调用中的尾逗号（Jeff Morrison）</li></ul><h3 id="Async-Functions"><a href="#Async-Functions" class="headerlink" title="Async Functions"></a>Async Functions</h3><p>Async Functions也就是我们常说的Async/Await，相信大家对于这个概念都已经不陌生了。Async/Await是一种用于处理JS异步操作的语法糖，可以帮助我们摆脱回调地狱，编写更加优雅的代码。</p><p>通俗的理解，async关键字的作用是告诉编译器对于标定的函数要区别对待。当编译器遇到标定的函数中的await关键字时，要暂时停止运行，带到await标定的函数处理完毕后，再进行相应操作。如果该函数fulfiled了，则返回值是fulfillment value，否则得到的就是reject value。</p><p>下面通过拿普通的promise写法来对比，就很好理解了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> otherAsyncFunc();</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Equivalent to:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> otherAsyncFunc()</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按顺序处理多个异步函数的时候优势更为明显：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result1 = <span class="keyword">await</span> otherAsyncFunc1();</span><br><span class="line">    <span class="built_in">console</span>.log(result1);</span><br><span class="line">    <span class="keyword">const</span> result2 = <span class="keyword">await</span> otherAsyncFunc2();</span><br><span class="line">    <span class="built_in">console</span>.log(result2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Equivalent to:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> otherAsyncFunc1()</span><br><span class="line">    .then(<span class="function"><span class="params">result1</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result1);</span><br><span class="line">        <span class="keyword">return</span> otherAsyncFunc2();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result2</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并行处理多个异步函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [result1, result2] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">        otherAsyncFunc1(),</span><br><span class="line">        otherAsyncFunc2(),</span><br><span class="line">    ]);</span><br><span class="line">    <span class="built_in">console</span>.log(result1, result2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Equivalent to:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">        otherAsyncFunc1(),</span><br><span class="line">        otherAsyncFunc2(),</span><br><span class="line">    ])</span><br><span class="line">    .then([result1, result2] =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result1, result2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> otherAsyncFunc();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Equivalent to:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> otherAsyncFunc()</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Async Functions若是要展开去讲，可以占用很大段的篇幅。鉴于本文是一篇介绍性文章，再次不再进行深入。</p><h3 id="SharedArrayBuffer和Atomics"><a href="#SharedArrayBuffer和Atomics" class="headerlink" title="SharedArrayBuffer和Atomics"></a>SharedArrayBuffer和Atomics</h3><p><strong>注</strong>，如果之前您没有接触过ArrayBuffer相关知识的话，建议您从内存管理速成教程系列漫画解说入门，强推：<br><a href="https://hacks.mozilla.org/2017/06/a-crash-course-in-memory-management/" target="_blank" rel="noopener">A crash course in memory management</a><br><a href="https://hacks.mozilla.org/2017/06/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers/" target="_blank" rel="noopener">A cartoon intro to ArrayBuffers and SharedArrayBuffers</a><br><a href="https://hacks.mozilla.org/2017/06/avoiding-race-conditions-in-sharedarraybuffers-with-atomics/" target="_blank" rel="noopener">Avoiding race conditions in SharedArrayBuffers with Atomics</a></p><hr><p>ECMAScript 2017 特性 SharedArrayBuffer 和 atomics”，由Lars T. Hansen设计。它引入了一个新的构造函数 SharedArrayBuffer 和 具有辅助函数的命名空间对象 Atomics。</p><p>在我们开始之前，让我们澄清两个相似但截然不同的术语：并行(Parallelism) 和 并发(Concurrency) 。他们存在许多定义，我使用的定义如下</p><ul><li>并行(Parallelism) (parallel 并行 vs. serial 串行)：同时执行多个任务；</li><li>并发(Concurrency) (concurrent 并发 vs. sequential 连续)：在重叠的时间段内（而不是一个接一个）执行几个任务。</li></ul><h4 id="JS并行的历史"><a href="#JS并行的历史" class="headerlink" title="JS并行的历史"></a>JS并行的历史</h4><ul><li>JavaScript 在单线程中执行。某些任务可以异步执行：浏览器通常会在单线程中运行这些任务，然后通过回调将结果重新加入到单线程中。</li><li>Web workers 将任务并行引入了 JavaScript ：这些是相对重量级的进程。每个 workers 都有自己的全局环境。默认情况下，不共享任何内容。 workers 之间的通信（或在 workers 和主线程之间的通信）发展：<ul><li>起初，你只能发送和接收字符串。</li><li>然后，引入结构化克隆：可以发送和接收数据副本。结构化克隆适用于大多数数据（JSON 数据，TypedArray，正则表达式，Blob对象，ImageData对象等）。它甚至可以正确处理对象之间的循环引用。但是，不能克隆 error 对象，function 对象和 DOM 节点。</li><li>可在 workers 之间的转移数据:当接收方获得数据时，发送方失去访问权限。</li></ul></li><li>通过 WebGL 使用 GPU 计算(它倾向于数据并行处理) </li></ul><h4 id="共享数组缓冲区（Shared-Array-Buffers）"><a href="#共享数组缓冲区（Shared-Array-Buffers）" class="headerlink" title="共享数组缓冲区（Shared Array Buffers）"></a>共享数组缓冲区（Shared Array Buffers）</h4><p>共享阵列缓冲区是更高并发抽象的基本构建块。它们允许您在多个 workers 和主线程之间共享 SharedArrayBuffer 对象的字节(该缓冲区是共享的，用于访问字节，将其封装在一个 TypedArray 中)这种共享有两个好处：</p><p>你可以更快地在 workers 之间共享数据。<br>workers 之间的协调变得更简单和更快（与 postMessage() 相比）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(<span class="string">'worker.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要分享的buffer</span></span><br><span class="line"><span class="keyword">const</span> sharedBuffer = <span class="keyword">new</span> SharedArrayBuffer( <span class="comment">// (A)</span></span><br><span class="line">    <span class="number">10</span> * <span class="built_in">Int32Array</span>.BYTES_PER_ELEMENT); <span class="comment">// 10 elements</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Worker共用sharedBuffer</span></span><br><span class="line">worker.postMessage(&#123;sharedBuffer&#125;); <span class="comment">// clone</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅限本地使用</span></span><br><span class="line"><span class="keyword">const</span> sharedArray = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(sharedBuffer); <span class="comment">// (B)</span></span><br></pre></td></tr></table></figure><p>创建一个共享数组缓冲区（Shared Array Buffers）的方法与创建普通的数组缓冲区(Array Buffer)类似：通过调用构造函数，并以字节的形式指定缓冲区的大小(行A)。你与 workers 共享的是 缓冲区（buffer） 。对于你自己的本地使用，你通常将共享数组缓冲区封装在 TypedArray 中(行B)。</p><p>workers的实现如下所列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line">self.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;sharedBuffer&#125; = event.data;</span><br><span class="line">    <span class="keyword">const</span> sharedArray = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(sharedBuffer); <span class="comment">// (A)</span></span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="sharedArrayBuffer-的-API"><a href="#sharedArrayBuffer-的-API" class="headerlink" title="sharedArrayBuffer 的 API"></a>sharedArrayBuffer 的 API</h4><p>构造函数：</p><ul><li>new SharedArrayBuffer(length)<br>创建一个 length 字节的 buffer(缓冲区)。</li></ul><p>静态属性：</p><ul><li>get SharedArrayBuffer[Symbol.species]<br>默认情况下返回 this。 覆盖以控制 slice() 的返回。</li></ul><p>实例属性：</p><ul><li><p>get SharedArrayBuffer.prototype.byteLength()<br>返回 buffer(缓冲区) 的字节长度。</p></li><li><p>SharedArrayBuffer.prototype.slice(start, end)<br>创建一个新的 this.constructor[Symbol.species] 实例，并用字节填充从（包括）开始到（不包括）结束的索引。</p></li></ul><h4 id="Atomics-安全访问共享数据"><a href="#Atomics-安全访问共享数据" class="headerlink" title="Atomics: 安全访问共享数据"></a>Atomics: 安全访问共享数据</h4><p>举一个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">sharedArray[<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">sharedArray[<span class="number">2</span>] = <span class="number">22</span>;</span><br></pre></td></tr></table></figure><p>在单线程中，您可以重新排列这些写入操作，因为在中间没有读到任何内容。 对于多线程，当你期望以特定顺序执行写入操作时，就会遇到麻烦：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">while</span> (sharedArray[<span class="number">2</span>] !== <span class="number">22</span>) ;</span><br><span class="line"><span class="built_in">console</span>.log(sharedArray[<span class="number">1</span>]); <span class="comment">// 0 or 11</span></span><br></pre></td></tr></table></figure><p>Atomics 方法可以用来与其他 workers 进行同步。例如，以下两个操作可以让你读取和写入数据，并且不会被编译器重新排列：</p><ul><li>Atomics.load(ta : TypedArray, index)</li><li>Atomics.store(ta : TypedArray, index, value : T)</li></ul><p>这个想法是使用常规操作读取和写入大多数数据，而 Atomics 操作（load ，store 和其他操作）可确保读取和写入安全。通常，您将使用自定义同步机制，例如锁，其实现基于Atomics。</p><p>这是一个非常简单的例子，它总是有效的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'notifying...'</span>);</span><br><span class="line">Atomics.store(sharedArray, <span class="number">0</span>, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">while</span> (Atomics.load(sharedArray, <span class="number">0</span>) !== <span class="number">123</span>) ;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'notified'</span>);</span><br></pre></td></tr></table></figure><h4 id="Atomics-的-API"><a href="#Atomics-的-API" class="headerlink" title="Atomics 的 API"></a>Atomics 的 API</h4><p>Atomic 函数的主要操作数必须是 Int8Array ，Uint8Array ，Int16Array ，Uint16Array ，Int32Array 或 Uint32Array 的一个实例。它必须包裹一个 SharedArrayBuffer 。</p><p>所有函数都以 atomically 方式进行操作。存储操作的顺序是固定的并且不能由编译器或 CPU 重新排序。</p><p>加载和存储</p><ul><li>Atomics.load(ta : TypedArray<t>, index) : T<br>读取和返回 ta[index] 上的元素，返回数组指定位置上的值。</t></li><li>Atomics.store(ta : TypedArray<t>, index, value : T) : T<br>在 ta[index] 上写入 value，并且返回 value。</t></li><li>Atomics.exchange(ta : TypedArray<t>, index, value : T) : T<br>将 ta[index] 上的元素设置为 value ，并且返回索引 index 原先的值。</t></li><li>Atomics.compareExchange(ta : TypedArray<t>, index, expectedValue, replacementValue) : T<br>如果 ta[index] 上的当前元素为 expectedValue , 那么使用 replacementValue 替换。并且返回索引 index 原先（或者未改变）的值。</t></li></ul><p>简单修改 TypeArray 元素</p><p>以下每个函数都会在给定索引处更改 TypeArray 元素：它将一个操作符应用于元素和参数，并将结果写回元素。它返回元素的原始值。</p><ul><li>Atomics.add(ta : TypedArray<t>, index, value) : T<br>执行 ta[index] += value 并返回 ta[index] 的原始值。</t></li><li>Atomics.sub(ta : TypedArray<t>, index, value) : T<br>执行 ta[index] -= value 并返回 ta[index] 的原始值。</t></li><li>Atomics.and(ta : TypedArray<t>, index, value) : T<br>执行 ta[index] &amp;= value 并返回 ta[index] 的原始值。</t></li><li>Atomics.or(ta : TypedArray<t>, index, value) : T<br>执行 ta[index] |= value 并返回 ta[index] 的原始值。</t></li><li>Atomics.xor(ta : TypedArray<t>, index, value) : T<br>执行 ta[index] ^= value 并返回 ta[index] 的原始值。</t></li></ul><p>等待和唤醒</p><ul><li>Atomics.wait(ta: Int32Array, index, value, timeout=Number.POSITIVE_INFINITY) : (‘not-equal’ | ‘ok’ | ‘timed-out’)<br>如果 ta[index] 的当前值不是 value ，则返回 ‘not-equal’。否则继续等待，直到我们通过 Atomics.wake() 唤醒或直到等待超时。 在前一种情况下，返回 ‘ok’。在后一种情况下，返回’timed-out’。timeout 以毫秒为单位。记住此函数执行的操作：“如果 ta[index] 为 value，那么继续等待” 。</li><li>Atomics.wake(ta : Int32Array, index, count)<br>唤醒等待在 ta[index] 上的 count workers。</li></ul><h3 id="Object-values-and-Object-entries"><a href="#Object-values-and-Object-entries" class="headerlink" title="Object.values and Object.entries"></a>Object.values and Object.entries</h3><p>Object.values() 方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for…in循环的顺序相同 ( 区别在于for-in循环枚举原型链中的属性 )。</p><p>obj参数是需要待操作的对象。可以是一个对象，或者一个数组（是一个带有数字下标的对象，[10,20,30] -&gt; {0: 10,1: 20,2: 30})。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">x</span>: <span class="string">'xxx'</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj); <span class="comment">// ['xxx', 1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = [<span class="string">'e'</span>, <span class="string">'s'</span>, <span class="string">'8'</span>]; <span class="comment">// 相当于 &#123; 0: 'e', 1: 's', 2: '8' &#125;;</span></span><br><span class="line"><span class="built_in">Object</span>.values(obj); <span class="comment">// ['e', 's', '8']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们使用数字键值时，返回的是数字排序</span></span><br><span class="line"><span class="comment">// 根据键值排序</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">10</span>: <span class="string">'xxx'</span>, <span class="number">1</span>: <span class="string">'yyy'</span>, <span class="number">3</span>: <span class="string">'zzz'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj); <span class="comment">// ['yyy', 'zzz', 'xxx']</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.values(<span class="string">'es8'</span>); <span class="comment">// ['e', 's', '8']</span></span><br></pre></td></tr></table></figure><p>Object.entries 方法返回一个给定对象自身可遍历属性 [key, value] 的数组， 排序规则和 Object.values 一样。这个方法的声明比较琐碎:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">x</span>: <span class="string">'xxx'</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj); <span class="comment">// [['x', 'xxx'], ['y', 1]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = [<span class="string">'e'</span>, <span class="string">'s'</span>, <span class="string">'8'</span>];</span><br><span class="line"><span class="built_in">Object</span>.entries(obj); <span class="comment">// [['0', 'e'], ['1', 's'], ['2', '8']]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">10</span>: <span class="string">'xxx'</span>, <span class="number">1</span>: <span class="string">'yyy'</span>, <span class="number">3</span>: <span class="string">'zzz'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj); <span class="comment">// [['1', 'yyy'], ['3', 'zzz'], ['10': 'xxx']]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.entries(<span class="string">'es8'</span>); <span class="comment">// [['0', 'e'], ['1', 's'], ['2', '8']]</span></span><br></pre></td></tr></table></figure><h3 id="String-padding"><a href="#String-padding" class="headerlink" title="String padding"></a>String padding</h3><p>为 String 对象增加了 2 个函数：padStart 和 padEnd。</p><p>像它们名字那样，这几个函数的主要目的就是填补字符串的首部和尾部，为了使得到的结果字符串的长度能达到给定的长度。你可以通过特定的字符，或者字符串，或者默认的空格填充它。下面是函数的声明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.padStart(targetLength [, padString])</span><br><span class="line">str.padEnd(targetLength [, padString])</span><br></pre></td></tr></table></figure><p>这些函数的第一个参数是 targetLength（目标长度），这个是结果字符串的长度。第二个参数是可选的 padString（填充字符），一个用于填充到源字符串的字符串。默认值是空格。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'es8'</span>.padStart(<span class="number">2</span>);          <span class="comment">// 'es8'</span></span><br><span class="line"><span class="string">'es8'</span>.padStart(<span class="number">5</span>);          <span class="comment">// '  es8'</span></span><br><span class="line"><span class="string">'es8'</span>.padStart(<span class="number">6</span>, <span class="string">'woof'</span>);  <span class="comment">// 'wooes8'</span></span><br><span class="line"><span class="string">'es8'</span>.padStart(<span class="number">14</span>, <span class="string">'wow'</span>);  <span class="comment">// 'wowwowwowwoes8'</span></span><br><span class="line"><span class="string">'es8'</span>.padStart(<span class="number">7</span>, <span class="string">'0'</span>);     <span class="comment">// '0000es8'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'es8'</span>.padEnd(<span class="number">2</span>);            <span class="comment">// 'es8'</span></span><br><span class="line"><span class="string">'es8'</span>.padEnd(<span class="number">5</span>);            <span class="comment">// 'es8  '</span></span><br><span class="line"><span class="string">'es8'</span>.padEnd(<span class="number">6</span>, <span class="string">'woof'</span>);    <span class="comment">// 'es8woo'</span></span><br><span class="line"><span class="string">'es8'</span>.padEnd(<span class="number">14</span>, <span class="string">'wow'</span>);    <span class="comment">// 'es8wowwowwowwo'</span></span><br><span class="line"><span class="string">'es8'</span>.padEnd(<span class="number">7</span>, <span class="string">'6'</span>);       <span class="comment">// 'es86666'</span></span><br></pre></td></tr></table></figure><h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a>Object.getOwnPropertyDescriptors</h3><p>getOwnPropertyDescriptors 方法返回指定对象所有自身属性的描述对象。属性描述对象是直接在对象上定义的，而不是继承于对象的原型。ES2017加入这个函数的主要动机在于方便将一个对象深度拷贝给另一个对象，同时可以将getter/setter拷贝。声明如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br></pre></td></tr></table></figure><p>obj 是待操作对象。返回的描述对象键值有：configurable, enumerable, writable, get, set and value。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; </span><br><span class="line">  get es7() &#123; <span class="keyword">return</span> <span class="number">777</span>; &#125;,</span><br><span class="line">  get es8() &#123; <span class="keyword">return</span> <span class="number">888</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   es7: &#123;</span></span><br><span class="line"><span class="comment">//     configurable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     get: function es7()&#123;&#125;, //the getter function</span></span><br><span class="line"><span class="comment">//     set: undefined</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   es8: &#123;</span></span><br><span class="line"><span class="comment">//     configurable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     get: function es8()&#123;&#125;, //the getter function</span></span><br><span class="line"><span class="comment">//     set: undefined</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h3 id="结尾逗号"><a href="#结尾逗号" class="headerlink" title="结尾逗号"></a>结尾逗号</h3><p>结尾逗号用代码展示非常明了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数定义时</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    param1,</span></span></span><br><span class="line"><span class="function"><span class="params">    param2,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用时</span></span><br><span class="line">foo(</span><br><span class="line">    <span class="string">'abc'</span>,</span><br><span class="line">    <span class="string">'def'</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象中</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    first: <span class="string">'Jane'</span>,</span><br><span class="line">    last: <span class="string">'Doe'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组中</span></span><br><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">    <span class="string">'red'</span>,</span><br><span class="line">    <span class="string">'green'</span>,</span><br><span class="line">    <span class="string">'blue'</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>这个改动有什么好处呢？</p><ul><li>首先，重新排列项目更简单，因为如果最后一项更改其位置，则不必添加和删除逗号。</li><li>其次，它可以帮助版本控制系统跟踪实际发生的变化。例如，从：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">'foo'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">'foo'</span>,</span><br><span class="line">    <span class="string">'bar'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>导致线条’foo’和线条’bar’被标记为已更改，即使唯一真正的变化是后一条线被添加。</p><h2 id="ES9新特性（ECMAScript-2018）"><a href="#ES9新特性（ECMAScript-2018）" class="headerlink" title="ES9新特性（ECMAScript 2018）"></a>ES9新特性（ECMAScript 2018）</h2><p><img src="/2018/11/27/细解JavaScript-ES7-ES8-ES9-新特性/es2018.png" alt="ECMAScript 2017"></p><p>ES9的新特性索引如下：</p><p>主要新功能：</p><ul><li>异步迭代（Domenic Denicola，Kevin Smith）</li><li>Rest/Spread 属性（SebastianMarkbåge）</li></ul><p>新的正则表达式功能：</p><ul><li>RegExp named capture groups（Gorkem Yakin，Daniel Ehrenberg）</li><li>RegExp Unicode Property Escapes（Mathias Bynens）</li><li>RegExp Lookbehind Assertions（Gorkem Yakin，NozomuKatō，Daniel Ehrenberg）</li><li>s (dotAll) flag for regular expressions（Mathias Bynens）</li></ul><p>其他新功能：</p><ul><li>Promise.prototype.finally() （Jordan Harband）</li><li>模板字符串修改（Tim Disney）</li></ul><h3 id="异步迭代"><a href="#异步迭代" class="headerlink" title="异步迭代"></a>异步迭代</h3><h4 id="首先来回顾一下同步迭代器："><a href="#首先来回顾一下同步迭代器：" class="headerlink" title="首先来回顾一下同步迭代器："></a>首先来回顾一下同步迭代器：</h4><p>ES6引入了同步迭代器，其工作原理如下：</p><ul><li>Iterable：一个对象，表示可以通过Symbol.iterator方法进行迭代。</li><li>Iterator：通过调用iterable [Symbol.iterator] ()返回的对象。它将每个迭代元素包装在一个对象中，并通过其next()方法一次返回一个。</li><li>IteratorResult：返回的对象next()。属性value包含一个迭代的元素，属性done是true 后最后一个元素。</li></ul><p>示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iterable = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line"><span class="keyword">const</span> iterator = iterable[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">iterator.next()</span><br><span class="line"><span class="comment">// &#123; value: 'a', done: false &#125;</span></span><br><span class="line">iterator.next()</span><br><span class="line"><span class="comment">// &#123; value: 'b', done: false &#125;</span></span><br><span class="line">iterator.next()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></p><h4 id="异步迭代器"><a href="#异步迭代器" class="headerlink" title="异步迭代器"></a>异步迭代器</h4><p>先前的迭代方式是同步的，并不适用于异步数据源。例如，在以下代码中，readLinesFromFile()无法通过同步迭代传递其异步数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> line <span class="keyword">of</span> readLinesFromFile(fileName)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步迭代器和常规迭代器的工作方式非常相似，但是异步迭代器涉及promise:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 普通迭代器:</span></span><br><span class="line">  <span class="keyword">const</span> iterator = createNumberIterator();</span><br><span class="line">  iterator.next(); <span class="comment">// Object &#123;value: 1, done: false&#125;</span></span><br><span class="line">  iterator.next(); <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">  iterator.next(); <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">  iterator.next(); <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步迭代器:</span></span><br><span class="line">  <span class="keyword">const</span> asyncIterator = createAsyncNumberIterator();</span><br><span class="line">  <span class="keyword">const</span> p = asyncIterator.next(); <span class="comment">// Promise</span></span><br><span class="line">  <span class="keyword">await</span> p;<span class="comment">// Object &#123;value: 1, done: false&#125;</span></span><br><span class="line">  <span class="keyword">await</span> asyncIterator.next(); <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">  <span class="keyword">await</span> asyncIterator.next(); <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">  <span class="keyword">await</span> asyncIterator.next(); <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步迭代器对象的next()方法返回了一个Promise，解析后的值跟普通的迭代器类似。<br>用法：<code>iterator.next().then(({ value, done })=&gt; {//{value: ‘some val’, done: false}}</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="number">1</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="number">2</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="number">3</span>)),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> p <span class="keyword">of</span> promises) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">//1 ,2 3</span></span><br></pre></td></tr></table></figure><h3 id="Rest-Spread-属性"><a href="#Rest-Spread-属性" class="headerlink" title="Rest/Spread 属性"></a>Rest/Spread 属性</h3><p>这个就是我们通常所说的rest参数和扩展运算符，这项特性在ES6中已经引入，但是ES6中的作用对象仅限于数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">restParam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restParam</span>(<span class="params">p1, p2, ...p3</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// p1 = 1</span></span><br><span class="line">  <span class="comment">// p2 = 2</span></span><br><span class="line">  <span class="comment">// p3 = [3, 4, 5]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> values = [<span class="number">99</span>, <span class="number">100</span>, <span class="number">-1</span>, <span class="number">48</span>, <span class="number">16</span>];</span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.max(...values) ); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><p>在ES9中，为对象提供了像数组一样的rest参数和扩展运算符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; a, ...param &#125; = obj;</span><br><span class="line">  <span class="built_in">console</span>.log(a)     <span class="comment">//1</span></span><br><span class="line">  <span class="built_in">console</span>.log(param) <span class="comment">//&#123;b: 2, c: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;a, ...param&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);    <span class="comment">//1</span></span><br><span class="line">  <span class="built_in">console</span>.log(param) <span class="comment">//&#123;b: 2, c: 3&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正则表达式命名捕获组"><a href="#正则表达式命名捕获组" class="headerlink" title="正则表达式命名捕获组"></a>正则表达式命名捕获组</h3><h4 id="编号的捕获组"><a href="#编号的捕获组" class="headerlink" title="编号的捕获组"></a>编号的捕获组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正则表达式命名捕获组</span></span><br><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/([0-9]&#123;4&#125;)-([0-9]&#123;2&#125;)-([0-9]&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj[<span class="number">1</span>]; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj[<span class="number">2</span>]; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj[<span class="number">3</span>]; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure><p>通过数字引用捕获组有几个缺点：</p><ul><li>找到捕获组的数量是一件麻烦事：必须使用括号。</li><li>如果要了解组的用途，则需要查看正则表达式。</li><li>如果更改捕获组的顺序，则还必须更改匹配代码。</li></ul><h4 id="命名的捕获组"><a href="#命名的捕获组" class="headerlink" title="命名的捕获组"></a>命名的捕获组</h4><p>ES9中可以通过名称来识别捕获组：<code>(?&lt;year&gt;[0-9]{4})</code></p><p>在这里，我们用名称标记了前一个捕获组year。该名称必须是合法的JavaScript标识符（认为变量名称或属性名称）。匹配后，您可以通过访问捕获的字符串matchObj.groups.year来访问。</p><p>让我们重写前面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj.groups.year; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj.groups.month; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj.groups.day; <span class="comment">// 31</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用解构语法更为简便</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">groups</span>: &#123;day, year&#125;&#125; = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(year); <span class="comment">// 1999</span></span><br><span class="line"><span class="built_in">console</span>.log(day); <span class="comment">// 31</span></span><br></pre></td></tr></table></figure><p>可以发现，命名捕获组有以下优点：</p><ul><li>找到捕获组的“ID”更容易。</li><li>匹配代码变为自描述性的，因为捕获组的ID描述了正在捕获的内容。</li><li>如果更改捕获组的顺序，则无需更改匹配代码。</li><li>捕获组的名称也使正则表达式更容易理解，因为您可以直接看到每个组的用途。</li></ul><h3 id="正则表达式-Unicode-转义"><a href="#正则表达式-Unicode-转义" class="headerlink" title="正则表达式 Unicode 转义"></a>正则表达式 Unicode 转义</h3><p>该特性允许您使用<code>\p{}</code>通过提及大括号内的Unicode字符属性来匹配字符,在正则表达式中使用标记 <code>u</code> (unicode) 设置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/^\p&#123;White_Space&#125;+$/u.test(<span class="string">'\t \n\r'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">/^\p&#123;Script=Greek&#125;+$/u.test(<span class="string">'μετά'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="新方法匹配中文字符"><a href="#新方法匹配中文字符" class="headerlink" title="新方法匹配中文字符"></a>新方法匹配中文字符</h4><p>由于在Unicode里面，中文字符对应的Unicode Script是<strong>Han</strong>，于是我们就可以用这个reg来匹配中文：</p><p><code>/\p{Script=Han}/u</code></p><p>这样我们就可以不用记忆繁琐又不好记的<code>/[\u4e00-\u9fa5]/</code>了，况且这个表达式已经有些年头了，说实话，后来又新增的属性为Han的字符并不在这个范围内，因此这个有年头reg并不一定好使。</p><p>我随便从网上找了一个Unicode8.0添加的中文字符“𬬭”,我测了一下两种reg的兼容性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">oldReg=<span class="regexp">/[\u4e00-\u9fa5]/</span></span><br><span class="line">newReg=<span class="regexp">/\p&#123;Script=Han&#125;/u</span></span><br><span class="line"></span><br><span class="line">oldReg.test(<span class="string">'abc'</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">newReg.test(<span class="string">'abc'</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">oldReg.test(<span class="string">'地平线'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">newReg.test(<span class="string">'地平线'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">oldReg.test(<span class="string">'𬬭'</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">newReg.test(<span class="string">'𬬭'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><a href="http://www.unicode.org/charts/PDF/U4E00.pdf" target="_blank" rel="noopener">http://www.unicode.org/charts/PDF/U4E00.pdf</a></p><p>可以参考一下这个PDF，是Unicode的汉字全集，从524页9FA6至526页（最后一页）用旧匹配方式都无法生效。</p><p><img src="/2018/11/27/细解JavaScript-ES7-ES8-ES9-新特性/Unicode.png" alt="Unicode"></p><h4 id="一些对于Unicode的科普"><a href="#一些对于Unicode的科普" class="headerlink" title="一些对于Unicode的科普"></a>一些对于Unicode的科普</h4><ul><li><p>Name：唯一名称，由大写字母，数字，连字符和空格组成。例如：</p><ul><li>A： Name = LATIN CAPITAL LETTER A</li><li>😀： Name = GRINNING FACE</li></ul></li><li><p>General_Category：对字符进行分类。例如：</p><ul><li>X： General_Category = Lowercase_Letter</li><li>$： General_Category = Currency_Symbol</li></ul></li><li><p>White_Space：用于标记不可见的间距字符，例如空格，制表符和换行符。例如：</p><ul><li>\ T： White_Space = True</li><li>π： White_Space = False</li></ul></li><li><p>Age：引入字符的Unicode标准版本。例如：欧元符号€在Unicode标准的2.1版中添加。</p><ul><li>€： Age = 2.1</li></ul></li><li><p>Script：是一个或多个书写系统使用的字符集合。</p><ul><li>有些脚本支持多种写入系统。例如，拉丁文脚本支持英语，法语，德语，拉丁语等书写系统。</li><li>某些语言可以用多个脚本支持的多个备用写入系统编写。例如，土耳其语在20世纪初转换为拉丁文字之前使用了阿拉伯文字。</li><li>例子：<ul><li>α： Script = Greek</li><li>Д： Script = Cyrillic</li></ul></li></ul></li></ul><h4 id="正则表达式的Unicode属性转义"><a href="#正则表达式的Unicode属性转义" class="headerlink" title="正则表达式的Unicode属性转义"></a>正则表达式的Unicode属性转义</h4><ul><li><p>匹配其属性prop具有值的所有字符value：</p><p>  <code>\p{prop=value}</code></p></li><li><p>匹配所有没有属性prop值的字符value：</p><p>  <code>\P{prop=value}</code></p></li><li><p>匹配二进制属性bin_prop为True的所有字符：</p><p>  <code>\p{bin_prop}</code></p></li><li><p>匹配二进制属性bin_prop为False的所有字符：</p><p>  <code>\P{bin_prop}</code></p></li><li><p>匹配空格：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\p&#123;White_Space&#125;+$/u.test(<span class="string">'\t \n\r'</span>)</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>匹配字母：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\p&#123;Letter&#125;+$/u.test(<span class="string">'πüé'</span>)</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>匹配希腊字母：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\p&#123;Script=Greek&#125;+$/u.test(<span class="string">'μετά'</span>)</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>匹配拉丁字母：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\p&#123;Script=Latin&#125;+$/u.test(<span class="string">'Grüße'</span>)</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="正则表达式反向断言"><a href="#正则表达式反向断言" class="headerlink" title="正则表达式反向断言"></a>正则表达式反向断言</h3><p>先来看下正则表达式先行断言是什么：</p><p>如获取货币的符号<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> noReLookahead = <span class="regexp">/\D(\d+)/</span>,</span><br><span class="line">      reLookahead = <span class="regexp">/\D(?=\d+)/</span>,</span><br><span class="line">      match1 = noReLookahead.exec(<span class="string">'$123.45'</span>),</span><br><span class="line">      match2 = reLookahead.exec(<span class="string">'$123.45'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match1[<span class="number">0</span>]); <span class="comment">// $123   </span></span><br><span class="line"><span class="built_in">console</span>.log(match2[<span class="number">0</span>]); <span class="comment">// $</span></span><br></pre></td></tr></table></figure></p><p>在ES9中可以允许反向断言：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reLookahead = <span class="regexp">/(?&lt;=\D)[\d\.]+/</span>;</span><br><span class="line">      match = reLookahead.exec(<span class="string">'$123.45'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match[<span class="number">0</span>]); <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure><p>使用?&lt;=进行反向断言，可以使用反向断言获取货币的价格，而忽略货币符号。</p><h3 id="正则表达式dotAll模式"><a href="#正则表达式dotAll模式" class="headerlink" title="正则表达式dotAll模式"></a>正则表达式dotAll模式</h3><p>正则表达式中点.匹配除回车外的任何单字符，标记s改变这种行为，允许行终止符的出现，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/hello.world/.test(<span class="string">'hello\nworld'</span>);  <span class="comment">// false</span></span><br><span class="line">/hello.world/s.test(<span class="string">'hello\nworld'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p>这个基本没什么好讲的，看名字就能看懂了。其用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">  .finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure><p>finally的回调总会被执行。</p><h3 id="模板字符串修改"><a href="#模板字符串修改" class="headerlink" title="模板字符串修改"></a>模板字符串修改</h3><p>ES2018 移除对 ECMAScript 在带标签的模版字符串中转义序列的语法限制。<br>之前，\u开始一个 unicode 转义，\x开始一个十六进制转义，\后跟一个数字开始一个八进制转义。这使得创建特定的字符串变得不可能，例如Windows文件路径 C:\uuu\xxx\111。</p><p>要取消转义序列的语法限制，可在模板字符串之前使用标记函数String.raw:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`\u&#123;54&#125;`</span></span><br><span class="line"><span class="comment">// "T"</span></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`\u&#123;54&#125;`</span></span><br><span class="line"><span class="comment">// "\u&#123;54&#125;"</span></span><br></pre></td></tr></table></figure><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>ECMAScript的演化不会停止，但是我们完全没必要害怕。除了ES6这个史无前例的版本带来了海量的信息和知识点以外，之后每年一发的版本都仅仅带有少量的增量更新，一年更新的东西花半个小时就能搞懂了，完全没必要畏惧。</p><p>Stay hungry. Stay foolish.</p>]]></content>
    
    <summary type="html">
    
      ECMAScript的演化不会停止，但是我们完全没必要害怕。除了ES6这个史无前例的版本带来了海量的信息和知识点以外，之后每年一发的版本都仅仅带有少量的增量更新，一年更新的东西花半个小时就能搞懂了，完全没必要畏惧。本文将带您花大约一个小时左右的时间，迅速过一遍ES7,ES8,ES9的新特性。
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://tuobaye0711.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>那些优雅灵性的JS代码片段</title>
    <link href="https://tuobaye0711.github.io/2018/04/04/%E9%82%A3%E4%BA%9B%E4%BC%98%E9%9B%85%E7%81%B5%E6%80%A7%E7%9A%84JS%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"/>
    <id>https://tuobaye0711.github.io/2018/04/04/那些优雅灵性的JS代码片段/</id>
    <published>2018-04-04T07:47:08.000Z</published>
    <updated>2020-02-06T03:34:11.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><hr><p>如果你甘于平凡，写代码对你来说可以就是Ctrl+C和Ctrl+V；如果你充满创造力，写代码也可以成为一门艺术。我们在平时总会遇到一些堪称优雅灵性的代码片段，在这里，仅以我之见，列举出我所见到的那一部分。</p><p>下面为了阅读方便，我会把<strong>代码的题目和莽夫解法放在一起，优雅灵性的解法放在最下面</strong>，希望能对您造成一定的冲击，看官们可以自己尝试一下，题目并不难。</p><p>当然，通往罗马的大路有千千万，可能您的解法更为优秀。如果这样，希望您能在评论区展示出来，让更多人看见~</p><p>注：以下所有题目均来自<a href="http://www.codewars.com" target="_blank" rel="noopener">codewars</a></p><p><img src="/2018/04/04/那些优雅灵性的JS代码片段/codewars.png" alt="codewars"></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><hr><ol><li><p>Create Phone Number</p><p> 题目：编写一个函数，它接受一个由10个整数组成的数组（0到9之间的数组），该函数以形似(123) 456-7890的电话号码的形式返回这些数字的字符串。</p><p> Example:</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createPhoneNumber([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>]) <span class="comment">// =&gt; returns "(123) 456-7890"</span></span><br></pre></td></tr></table></figure><p> 莽夫解法：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createPhoneNumber = <span class="function"><span class="params">n</span> =&gt;</span> <span class="string">"("</span> + n[<span class="number">0</span>] + n[<span class="number">1</span>] + n[<span class="number">2</span>] + <span class="string">") "</span> + n[<span class="number">3</span>] + n[<span class="number">4</span>] + n[<span class="number">5</span>] + <span class="string">"-"</span> + n[<span class="number">6</span>] + n[<span class="number">7</span>] + n[<span class="number">8</span>] + n[<span class="number">9</span>]</span><br></pre></td></tr></table></figure></li><li><p>Find the odd int</p><p> 题目：给定一个数组，找到出现奇数次的数字。</p><p> PS:将始终只有一个整数出现奇数次。</p><p> Example:</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findOdd([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">5</span>]); <span class="comment">// =&gt; returns -1</span></span><br></pre></td></tr></table></figure><p> 莽夫解法：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findOdd</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> i = A.splice(count,<span class="number">1</span>,<span class="string">'p'</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (i !== <span class="string">'p'</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> result = [i];</span><br><span class="line">            A.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">e, index</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (e === i)&#123;</span><br><span class="line">                    i === result[<span class="number">0</span>] ? result.pop(): result.push(i);</span><br><span class="line">                    A.splice(index, <span class="number">1</span>, <span class="string">'p'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (result.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> result[<span class="number">0</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (A.length &gt; count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Who likes it?</p><p> 题目：你可能知道Facebook或者其他网站的“喜欢”系统。人们可以“喜欢”博客文章，图片或其他项目。我们想要创建一份显示在这样项目旁边的文本。</p><p> 实现一个函数，它的输入是数组，其中包含喜欢该项目的人的姓名。返回值是如下格式的文本：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">likes [] <span class="comment">// must be "no one likes this"</span></span><br><span class="line">likes [<span class="string">"Peter"</span>] <span class="comment">// must be "Peter likes this"</span></span><br><span class="line">likes [<span class="string">"Jacob"</span>, <span class="string">"Alex"</span>] <span class="comment">// must be "Jacob and Alex like this"</span></span><br><span class="line">likes [<span class="string">"Max"</span>, <span class="string">"John"</span>, <span class="string">"Mark"</span>] <span class="comment">// must be "Max, John and Mark like this"</span></span><br><span class="line">likes [<span class="string">"Alex"</span>, <span class="string">"Jacob"</span>, <span class="string">"Mark"</span>, <span class="string">"Max"</span>] <span class="comment">// must be "Alex, Jacob and 2 others like this"</span></span><br></pre></td></tr></table></figure><p> 莽夫解法：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> likes = <span class="function"><span class="params">names</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (names.length) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="string">'no one likes this'</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> names[<span class="number">0</span>] + <span class="string">' likes this'</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> names[<span class="number">0</span>] + <span class="string">' and '</span> + names[<span class="number">1</span>] + <span class="string">' like this'</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> names[<span class="number">0</span>] + <span class="string">', '</span> + names[<span class="number">1</span>] + <span class="string">' and '</span> + names[<span class="number">2</span>] + <span class="string">' like this'</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> names[<span class="number">0</span>] + <span class="string">', '</span> + names[<span class="number">1</span>] + <span class="string">' and '</span> + (names.length - <span class="number">2</span>) + <span class="string">' others like this'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Shortest Word</p><p> 题目：给定一串单词，返回最短单词的长度。</p><p> 字符串永远不会为空，您不需要考虑不同的数据类型。</p><p> Example:</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findShort(<span class="string">"bitcoin take over the world maybe who knows perhaps"</span>) <span class="comment">// returns 3，因为最短单词是the和who，长度为3</span></span><br></pre></td></tr></table></figure><p> 莽夫解法：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其实也不是特别莽</span></span><br><span class="line"><span class="keyword">const</span> findShort = <span class="function"><span class="params">s</span> =&gt;</span> s.split(<span class="string">' '</span>).map(<span class="function"><span class="params">w</span> =&gt;</span> w.length).sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></li><li><p>Sum of Digits / Digital Root</p><p> 题目：创建一个计算digital root的函数。</p><p> digital root是数字中各位数字的递归总和。给定n，取n各位数字之和。如果该值是两位数或者更多，则继续以这种方式递归，直到产生一位数字，这个数字就是digital root。这只适用于自然数。</p><p> Example:</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">digital_root(<span class="number">16</span>)</span><br><span class="line">=&gt; <span class="number">1</span> + <span class="number">6</span></span><br><span class="line">=&gt; <span class="number">7</span></span><br><span class="line"></span><br><span class="line">digital_root(<span class="number">942</span>)</span><br><span class="line">=&gt; <span class="number">9</span> + <span class="number">4</span> + <span class="number">2</span></span><br><span class="line">=&gt; <span class="number">15</span> ...</span><br><span class="line">=&gt; <span class="number">1</span> + <span class="number">5</span></span><br><span class="line">=&gt; <span class="number">6</span></span><br><span class="line"></span><br><span class="line">digital_root(<span class="number">132189</span>)</span><br><span class="line">=&gt; <span class="number">1</span> + <span class="number">3</span> + <span class="number">2</span> + <span class="number">1</span> + <span class="number">8</span> + <span class="number">9</span></span><br><span class="line">=&gt; <span class="number">24</span> ...</span><br><span class="line">=&gt; <span class="number">2</span> + <span class="number">4</span></span><br><span class="line">=&gt; <span class="number">6</span></span><br><span class="line"></span><br><span class="line">digital_root(<span class="number">493193</span>)</span><br><span class="line">=&gt; <span class="number">4</span> + <span class="number">9</span> + <span class="number">3</span> + <span class="number">1</span> + <span class="number">9</span> + <span class="number">3</span></span><br><span class="line">=&gt; <span class="number">29</span> ...</span><br><span class="line">=&gt; <span class="number">2</span> + <span class="number">9</span></span><br><span class="line">=&gt; <span class="number">11</span> ...</span><br><span class="line">=&gt; <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">=&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure><p> 莽夫解法：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">digital_root</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num = n;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">arguments</span>.callee((num+<span class="string">''</span>).split(<span class="string">''</span>).reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">parseInt</span>(a) + <span class="built_in">parseInt</span>(b)</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="优雅-amp-灵性解"><a href="#优雅-amp-灵性解" class="headerlink" title="优雅&amp;灵性解"></a>优雅&amp;灵性解</h2><hr><ol><li><p>Create Phone Number</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPhoneNumber</span>(<span class="params">numbers</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> format = <span class="string">"(xxx) xxx-xxxx"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)&#123;</span><br><span class="line">        format = format.replace(<span class="string">'x'</span>, numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> format;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 使用一个format的模版，通过循环replace所有format里的x位，优雅且可读性强，让人眼前一亮。</p></li><li><p>Find the odd int</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> findOdd = <span class="function">(<span class="params">xs</span>) =&gt;</span> xs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a ^ b);</span><br></pre></td></tr></table></figure><p> 我猜起码70%的人看到这个解法会一愣。回想一下，自己多久没有用过位运算了？本题使用reduce()和按位异或操作，相当于所有出现偶数次的数按位异或后均为0，然后出现基数次的数字与0按位异或得到自己本身，从而得解。</p></li><li><p>Who likes it?</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">likes</span> (<span class="params">names</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> templates = [</span><br><span class="line">        <span class="string">'no one likes this'</span>,</span><br><span class="line">        <span class="string">'&#123;name&#125; likes this'</span>,</span><br><span class="line">        <span class="string">'&#123;name&#125; and &#123;name&#125; like this'</span>,</span><br><span class="line">        <span class="string">'&#123;name&#125;, &#123;name&#125; and &#123;name&#125; like this'</span>,</span><br><span class="line">        <span class="string">'&#123;name&#125;, &#123;name&#125; and &#123;n&#125; others like this'</span></span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">var</span> idx = <span class="built_in">Math</span>.min(names.length, <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> templates[idx].replace(<span class="regexp">/&#123;name&#125;|&#123;n&#125;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val === <span class="string">'&#123;name&#125;'</span> ? names.shift() : names.length;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个不用解释了，使用模版字符串，可别傻傻的手动拼写了。</p></li><li><p>Shortest Word</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findShort</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, s.split(<span class="string">' '</span>).map(<span class="function"><span class="params">w</span> =&gt;</span> w.length));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 面试中经常可能会遇到问apply和call的区别之类的题目，但是实际上在工作中有多少人用它们写过代码呢？</p></li><li><p>Sum of Digits / Digital Root</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">digital_root</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个解法堪称神来之笔。有些人可能看不懂，它利用了我们小学时期学的一条定理，“所有位相加之和是9的倍数的数字能被9整除”。这个您可能没印象了，但是“所有位相加之和是3的倍数的数字能被3整除”这个您一定知道吧，这是同样的道理。至于为什么(n-1)整除9以后再加1，是为了防止9的倍数本身求出0的解来。</p></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><hr><p>以上五段代码，分别通过replace、位运算、模版字符串、apply甚至是“所有位相加之和是9的倍数的数字能被9整除”这种定理都能拿来解题，实在是令人叹为观止。</p><p>有些操作是神来之笔，有些操作是可以学习的。我们要做的就是把能学习到的学习到，下次自己能用上，这就够了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><hr><p><a href="https://www.codewars.com/kata/create-phone-number" target="_blank" rel="noopener">1. Create Phone Number</a><br><a href="https://www.codewars.com/kata/find-the-odd-int" target="_blank" rel="noopener">2. Find the odd int</a><br><a href="https://www.codewars.com/kata/who-likes-it" target="_blank" rel="noopener">3. Who likes it?</a><br><a href="https://www.codewars.com/kata/shortest-word" target="_blank" rel="noopener">4. Shortest Word</a><br><a href="https://www.codewars.com/kata/sum-of-digits-slash-digital-root" target="_blank" rel="noopener">5. Sum of Digits / Digital Root</a></p>]]></content>
    
    <summary type="html">
    
      如果你甘于平凡，写代码对你来说可以就是Ctrl+C和Ctrl+V；如果你充满创造力，写代码也可以成为一门艺术。我们在平时总会遇到一些堪称优雅灵性的代码片段，在这里，仅以我之见，列举出我所见到的那一部分。
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://tuobaye0711.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>【译】Chrome浏览器开发者工具的13个有趣技巧——希望你已经掌握</title>
    <link href="https://tuobaye0711.github.io/2018/03/26/%E3%80%90%E8%87%AA%E8%AF%91%E3%80%91Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E7%9A%8412%E4%B8%AA%E6%9C%89%E8%B6%A3%E6%8A%80%E5%B7%A7%E2%80%94%E2%80%94%E5%B8%8C%E6%9C%9B%E5%B7%B2%E7%BB%8F%E6%8E%8C%E6%8F%A1/"/>
    <id>https://tuobaye0711.github.io/2018/03/26/【自译】Chrome浏览器开发者工具的12个有趣技巧——希望已经掌握/</id>
    <published>2018-03-26T03:27:06.000Z</published>
    <updated>2020-02-06T03:23:39.470Z</updated>
    
    <content type="html"><![CDATA[<p>Chrome浏览器提供了一套非常出色的开发者工具来帮助您在Web平台上开发。下面我将介绍13个有趣的技巧，掌握他们对你只有好处。</p><h3 id="1-在Elements面板中拖放元素"><a href="#1-在Elements面板中拖放元素" class="headerlink" title="1. 在Elements面板中拖放元素"></a>1. 在Elements面板中拖放元素</h3><hr><p>在Elements面板中，你可以拖放任意的HTML元素，并在整个页面中更改其位置：</p><p><img src="/2018/03/26/【自译】Chrome浏览器开发者工具的12个有趣技巧——希望已经掌握/1.gif" alt="Drag-and-drop in the Elements panel"></p><h3 id="2-在控制台中引用当前选定的元素"><a href="#2-在控制台中引用当前选定的元素" class="headerlink" title="2. 在控制台中引用当前选定的元素"></a>2. 在控制台中引用当前选定的元素</h3><hr><p>在Elements面板中，选择一个节点，然后输入$0控制台以引用它：</p><p><img src="/2018/03/26/【自译】Chrome浏览器开发者工具的12个有趣技巧——希望已经掌握/2.gif" alt="Reference the currently selected element in the Console"></p><h3 id="3-使用控制台中最后一个操作的值"><a href="#3-使用控制台中最后一个操作的值" class="headerlink" title="3. 使用控制台中最后一个操作的值"></a>3. 使用控制台中最后一个操作的值</h3><hr><p>使用$_引用在控制台执行的前一操作的返回值：</p><p><img src="/2018/03/26/【自译】Chrome浏览器开发者工具的12个有趣技巧——希望已经掌握/3.gif" alt="Use the value of the last operation in the Console"></p><h3 id="4-添加CSS并编辑元素状态"><a href="#4-添加CSS并编辑元素状态" class="headerlink" title="4. 添加CSS并编辑元素状态"></a>4. 添加CSS并编辑元素状态</h3><hr><p>在Elements面板中有2个超级有用的按钮。</p><p>第一个可以为你的选择器(selector)增加新的CSS属性：</p><p><img src="/2018/03/26/【自译】Chrome浏览器开发者工具的12个有趣技巧——希望已经掌握/4.gif" alt="Add CSS and edit the element state"></p><p>第二个可以为你触发选定元素的状态，这样你就可以看到当它处于活动状态(active)，悬停状态(hovered)，焦点状态(focus)等等时应用的样式：</p><p><img src="/2018/03/26/【自译】Chrome浏览器开发者工具的12个有趣技巧——希望已经掌握/4.2.png" alt="Add CSS and edit the element state"></p><h3 id="5-将修改后的CSS保存到文件"><a href="#5-将修改后的CSS保存到文件" class="headerlink" title="5. 将修改后的CSS保存到文件"></a>5. 将修改后的CSS保存到文件</h3><hr><p>点击你编辑的CSS文件的名称，进入到Sources面板，你会发现你的修改已经在里面了。然后你可以对你实时的编辑进行保存。</p><p>这个修改不适用于添加的新选择器，也不适用于element.style属性，仅仅适用于原有选择器。</p><p><img src="/2018/03/26/【自译】Chrome浏览器开发者工具的12个有趣技巧——希望已经掌握/5.gif" alt="Save to file the modified CSS"></p><h3 id="6-截图单个元素"><a href="#6-截图单个元素" class="headerlink" title="6. 截图单个元素"></a>6. 截图单个元素</h3><hr><p>选择一个元素，MAC下按cmd+shift+p、windows下按ctrl+shift+p来打开命令菜单，然后输入<strong>Capture node screenshot</strong>：</p><p><img src="/2018/03/26/【自译】Chrome浏览器开发者工具的12个有趣技巧——希望已经掌握/6.gif" alt="Screenshot a single element"></p><h3 id="7-使用CSS选择器查找元素"><a href="#7-使用CSS选择器查找元素" class="headerlink" title="7. 使用CSS选择器查找元素"></a>7. 使用CSS选择器查找元素</h3><hr><p>MAC下按cmd+f、windows下按ctrl+f来打开搜索框</p><p>您可以在其中键入任何字符串以匹配源代码，或者也可以使用CSS选择器让Chrome为您生成一个图像：</p><p><img src="/2018/03/26/【自译】Chrome浏览器开发者工具的12个有趣技巧——希望已经掌握/7.gif" alt="Find an element using CSS selectors"></p><h3 id="8-控制台中的shift和enter"><a href="#8-控制台中的shift和enter" class="headerlink" title="8. 控制台中的shift和enter"></a>8. 控制台中的shift和enter</h3><hr><p>要编写跨越控制台多行的命令，请按shift+enter</p><p>准备就绪后，在脚本末尾按Enter键即可执行该操作：</p><p><img src="/2018/03/26/【自译】Chrome浏览器开发者工具的12个有趣技巧——希望已经掌握/8.gif" alt="Shift-enter in the Console"></p><h3 id="9-跳转"><a href="#9-跳转" class="headerlink" title="9. 跳转"></a>9. 跳转</h3><hr><p>在Sources面板中：</p><ul><li><p>cmd+o(windows下ctrl+o) 显示你页面加载的所有文件</p></li><li><p>cmd+shift+o(windows下ctrl+shift+o) 显示当前文件中的symbols（属性、函数、类等）</p></li><li><p>cmd+o(windows下ctrl+o) 跳转到指定行</p></li></ul><p>准备就绪后，在脚本末尾按Enter键即可执行该操作：</p><p><img src="/2018/03/26/【自译】Chrome浏览器开发者工具的12个有趣技巧——希望已经掌握/9.png" alt="Go to…"></p><h3 id="10-监听表达式"><a href="#10-监听表达式" class="headerlink" title="10. 监听表达式"></a>10. 监听表达式</h3><hr><p>不需要一次又一次地输入一个变量名或者表达式，你只需将他们添加到监视列表中就可以时时观察它们的变化：</p><p><img src="/2018/03/26/【自译】Chrome浏览器开发者工具的12个有趣技巧——希望已经掌握/10.gif" alt="Watch Expression"></p><h3 id="11-XHR-Fetch调试"><a href="#11-XHR-Fetch调试" class="headerlink" title="11. XHR/Fetch调试"></a>11. XHR/Fetch调试</h3><hr><p>从调试器打开<strong>XHR/Fetch Breakpoints</strong>面板。</p><p>你可以针对某一个请求或者请求的关键字设置断点：</p><p><img src="/2018/03/26/【自译】Chrome浏览器开发者工具的12个有趣技巧——希望已经掌握/11.png" alt="XHR/Fetch debugging"></p><h3 id="12-调试DOM修改"><a href="#12-调试DOM修改" class="headerlink" title="12. 调试DOM修改"></a>12. 调试DOM修改</h3><hr><p>右键单击某个DOM元素，并选择Break on下的subtree modifications。这样调试器就可以在脚本遍历到该元素并且要修改它的时候自动停止，以让用户进行调试检查。</p><p><img src="/2018/03/26/【自译】Chrome浏览器开发者工具的12个有趣技巧——希望已经掌握/12.png" alt="XHR/Fetch debugging"></p><h3 id="13-找到CSS属性定义的位置"><a href="#13-找到CSS属性定义的位置" class="headerlink" title="13. 找到CSS属性定义的位置"></a>13. 找到CSS属性定义的位置</h3><hr><p>MAC使用cmd+鼠标左键(windows下使用ctrl+鼠标左键)点击Elements面板中的CSS属性，可以直接帮您定位到Source面板中相应CSS定义的位置：</p><p><img src="/2018/03/26/【自译】Chrome浏览器开发者工具的12个有趣技巧——希望已经掌握/13.gif" alt="Use the value of the last operation in the Console"></p><h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h3><hr><p><a href="https://flaviocopes.com/chrome-devtools-tips/" target="_blank" rel="noopener">https://flaviocopes.com/chrome-devtools-tips/</a></p>]]></content>
    
    <summary type="html">
    
      Chrome浏览器提供了一套非常出色的开发者工具来帮助您在Web平台上开发。下面我将介绍13个有趣的技巧，掌握他们对你只有好处。
    
    </summary>
    
    
      <category term="外文翻译" scheme="https://tuobaye0711.github.io/tags/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>开发环境备份</title>
    <link href="https://tuobaye0711.github.io/2018/03/01/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%A4%87%E4%BB%BD/"/>
    <id>https://tuobaye0711.github.io/2018/03/01/开发环境备份/</id>
    <published>2018-03-01T11:41:03.000Z</published>
    <updated>2020-02-06T03:33:26.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018，开工大吉！"><a href="#2018，开工大吉！" class="headerlink" title="2018，开工大吉！"></a>2018，开工大吉！</h1><p><img src="/2018/03/01/开发环境备份/hello2018.jpg" alt="2018，开工大吉"></p><p>过完年，从家里跑去1100多公里外去定亲，最近两天才回来。恰逢有个机会，换了台高配的工作站作开发用。由于公司内网的限制，没法直接把旧电脑的东西备份到新电脑上，遂把自己的开发环境备份到个人博客上，记录之，分享之。</p><hr><p>下面是我的开发环境：</p><ul><li><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js</a> 一个基于 Chrome V8 引擎的 JavaScript 运行环境，对于现如今的前端开发者而言几乎是必备的。</li><li><a href="https://www.python.org/" target="_blank" rel="noopener">Python</a> 个人爱好。</li><li><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VS Code</a> 主力编辑器，相当好用</li><li><a href="https://www.jetbrains.com/webstorm/" target="_blank" rel="noopener">WebStorm</a> 副编辑器，曾经用的比较多，现在已经逐步转向VS Code了。</li><li><a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">Sublime Text 3</a> 备用的副编辑器，现在常用来打开文本或者查看日志文件。</li><li><a href="https://www.jetbrains.com/pycharm/download/#section=windows" target="_blank" rel="noopener">PyCharm</a> 好用的python开发环境。</li><li><a href="https://www.google.cn/intl/zh-CN/chrome/?brand=CHBD&amp;gclid=EAIaIQobChMI4qaciMrM2QIVR4uPCh2oYAoXEAAYASAAEgIqpvD_BwE" target="_blank" rel="noopener">Chorme</a> 怎么能少得了chrome呢？</li><li><a href="https://www.mozilla.org/en-US/firefox/" target="_blank" rel="noopener">FireFox</a> 前端开发者常备浏览器之一。</li><li><a href="https://mobaxterm.mobatek.net/" target="_blank" rel="noopener">MobaXterm</a> 一款功能强大的SSH客户端。</li><li><a href="http://cmder.net/" target="_blank" rel="noopener">cmder</a> windows下最好的命令行工具。</li><li><a href="https://typora.io/" target="_blank" rel="noopener">Typora</a> 小巧好用的markdown阅读器、编辑器。</li><li><a href="https://mubu.com/" target="_blank" rel="noopener">幕布</a> 一键生成思维导图。</li><li><a href="https://www.scootersoftware.com/download.php" target="_blank" rel="noopener">Beyond Compare 4</a> 我最喜欢的代码比较工具。</li><li><a href="https://everything.en.softonic.com/" target="_blank" rel="noopener">Everything</a> 体积小但功能强大文件搜索工具。</li><li><a href="http://www.faststone.org/FSCaptureDetail.htm" target="_blank" rel="noopener">FastStone Capture</a> 可以满足我全部需求的截图工具。</li><li><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git bash</a> git工具。</li><li><a href="https://tortoisesvn.net/downloads.html" target="_blank" rel="noopener">TortoiseSVN</a> svn工具。</li><li><a href="https://www.mysql.com/cn/" target="_blank" rel="noopener">MySQL</a> 本地数据库。</li><li><a href="https://www.navicat.com/en/products/navicat-for-mysql" target="_blank" rel="noopener">Navicat for MySQL</a> 本地数据库可视化工具，别说我懒，确实是提高效率…</li><li><a href="https://www.softwareok.com/?seite=Freeware/Q-Dir" target="_blank" rel="noopener">Q-Dir</a> 文件四分屏工具，非常方便。</li><li><a href="https://www.ccleaner.com/ccleaner" target="_blank" rel="noopener">CCleaner</a> 垃圾清理工具，过段时间运行一次就可以了。</li><li><a href="http://cn.sitemapx.com/" target="_blank" rel="noopener">SitemapX</a> 一款网站地图生成工具。</li><li><a href="http://bizhi.sogou.com/index.html" target="_blank" rel="noopener">搜狗壁纸</a> 非常好用的自动更换壁纸和桌面整理功能，可惜已经三年多不更新了。</li><li><a href="http://www.fancynode.com.cn/pxcook" target="_blank" rel="noopener">PxCook</a> 像素大厨，高效易用的自动标注工具，前端开发神器。</li></ul><hr><p>以后若有新增工具，会持续更新~</p>]]></content>
    
    <summary type="html">
    
      2018，开工大吉！过完年，从家里跑去1100多公里外去定亲，最近两天才回来。恰逢有个机会，换了台高配的工作站作开发用。由于公司内网的限制，没法直接把旧电脑的东西备份到新电脑上，遂把自己的开发环境备份到个人博客上，记录之，分享之。
    
    </summary>
    
    
      <category term="拾遗" scheme="https://tuobaye0711.github.io/tags/%E6%8B%BE%E9%81%97/"/>
    
  </entry>
  
  <entry>
    <title>基于RBAC的分权分域用户权限系统数据库设计</title>
    <link href="https://tuobaye0711.github.io/2018/02/12/%E5%9F%BA%E4%BA%8ERBAC%E7%9A%84%E5%88%86%E6%9D%83%E5%88%86%E5%9F%9F%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <id>https://tuobaye0711.github.io/2018/02/12/基于RBAC的分权分域用户权限系统数据库设计/</id>
    <published>2018-02-12T08:02:24.000Z</published>
    <updated>2018-03-04T15:08:12.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><hr><p>最近要开发一个新的系统，系统里面可以有许多不同的社区，每个社区下面有不同的项目。项目和项目、社区和社区之间都是相互独立的。我所做的工作是设计一套权限管理系统，这套系统允许不同的用户在不同的社区或者项目之中有不同的权限，可以保证用户无法做出越权的操作。</p><p>经过了一番努力，设计出了一套基于RBAC的分权分域的用户权限系统。</p><p>首先介绍一下什么是RBAC:</p><blockquote><p>以角色为基础的访问控制（英语：Role-based access control, RBAC），是资讯安全领域中，一种较新且广为使用的访问控制机制，其不同于强制访问控制以及自由选定访问控制直接赋予使用者权限，而是将权限赋予角色。1996年，莱威·桑度（Ravi Sandhu）等人在前人的理论基础上，提出以角色为基础的访问控制模型，故该模型又被称为RBAC96。之后，美国国家标准局重新定义了以角色为基础的访问控制模型，并将之纳为一种标准，称之为NIST RBAC。<br>以角色为基础的访问控制模型是一套较强制访问控制以及自由选定访问控制更为中性且更具灵活性的访问控制技术。</p></blockquote><p>在一个组织中，会因为不同的作业功能产生不同的角色，执行某项操作的权限会被赋予特定的角色。组织成员或者工作人员（抑或其它系统用户）则被赋予不同的角色，这些用户通过被赋予角色来取得执行某项计算机系统功能的权限。</p><ul><li>S = 主体 = 一名使用者或自动代理人</li><li>R = 角色 = 被定义为一个授权等级的工作职位或职称</li><li>P = 权限 = 一种存取资源的方式</li><li>SE = 会期 = S，R或P之间的映射关系</li><li>SA = 主体指派</li><li>PA = 权限指派</li><li>RH = 角色阶层。能被表示为：≥（x ≥ y 代表 x 继承 y 的权限）</li><li>一个主体可对应多个角色。</li><li>一个角色可对应多个主体。</li><li>一个角色可拥有多个权限。</li><li>一种权限可被分配给许多个角色。</li><li>一个角色可以有专属于自己的权限。</li></ul><h2 id="数据库结构设计"><a href="#数据库结构设计" class="headerlink" title="数据库结构设计"></a>数据库结构设计</h2><hr><p>项目使用的mysql数据库，设计表格的大体结构如下：</p><p><img src="/2018/02/12/基于RBAC的分权分域用户权限系统数据库设计/分权分域数据库设计.png" alt="数据库结构设计"></p><p>蓝底模块为<strong>基本表</strong>，黄底模块为<strong>关系表</strong>。</p><p>基本表有</p><ul><li>t_user</li><li>t_role</li><li>t_permission</li><li>t_operation</li></ul><p>关系表有</p><ul><li>t_user_role_community</li><li>t_user_role_project</li><li>t_role_permission</li><li>t_permission_operation</li></ul><p>权限判断的主要思路是根据用户传过来的社区ID/项目ID+用户ID+发起的请求路径，通过多表联查，来确定用户在对应的社区/项目内所对应的角色是否具有权限执行响应请求的操作。</p><p>由于在域方面，有社区和项目两个尺度，其中社区包含项目。但是由于一些其他原因，在社区表中无法表示出与项目的从属关系，只能把t_user_role表复用，分身成两张表：t_user_role_community和t_user_role_project。</p><p>由于我们的鉴权系统整个流程都是一对多的关系，即一个用户可能对应多个角色，一个角色可能对应多种权限，一种权限又能对应多种操作。因此，一个用户能对应N多种操作，同时，由于中间的多重映射关系，一个用户对某个操作可能会对应多次。</p><p>我们采用多表联查的方式，输入项为用户+操作（操作具体表示为request的method+url），使用如下SQL语句进行查询，只要查询结果不为空，即证明用户有相应的操作权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    t_user_role_community</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> t_role_permission</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> t_permission_operation <span class="keyword">ON</span> t_user_role_community.strRole = t_role_permission.strRole</span><br><span class="line"><span class="keyword">AND</span> t_role_permission.nPermission = t_permission_operation.nPermission</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    nUser = <span class="number">10025</span></span><br><span class="line"><span class="keyword">AND</span> nCommunity = <span class="number">1</span></span><br><span class="line"><span class="keyword">AND</span> strMethod = <span class="string">'get'</span></span><br><span class="line"><span class="keyword">AND</span> strUrl = <span class="string">'/api/t_service'</span></span><br></pre></td></tr></table></figure><p>这样做实际上只查询了社区线的权限，此外还有项目线的权限以及非社区非项目线的权限（例如个人中心、系统管理之类的，我们把这部分的域直接设置为nCommunity=0，即项目编号为0），想要覆盖所有的域，我们相当于要同时多表联查三次，只要其中任意一次能够查到数据，则表明用户有执行该操作的权限。我们可以用UNION语句来实现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    t_user_role_community</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> t_role_permission</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> t_permission_operation <span class="keyword">ON</span> t_user_role_community.strRole = t_role_permission.strRole</span><br><span class="line"><span class="keyword">AND</span> t_role_permission.nPermission = t_permission_operation.nPermission</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    nUser = <span class="number">10025</span></span><br><span class="line"><span class="keyword">AND</span> (nCommunity = <span class="number">0</span> <span class="keyword">OR</span> nCommunity = <span class="number">0</span>)</span><br><span class="line"><span class="keyword">AND</span> strMethod = <span class="string">'get'</span></span><br><span class="line"><span class="keyword">AND</span> strUrl = <span class="string">'/api/t_service'</span>)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line">(<span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    t_user_role_project</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> t_role_permission</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> t_permission_operation <span class="keyword">ON</span> t_user_role_project.strRole = t_role_permission.strRole</span><br><span class="line"><span class="keyword">AND</span> t_role_permission.nPermission = t_permission_operation.nPermission</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    nUser = <span class="number">10025</span></span><br><span class="line"><span class="keyword">AND</span> nProject = <span class="number">0</span></span><br><span class="line"><span class="keyword">AND</span> strMethod = <span class="string">'get'</span></span><br><span class="line"><span class="keyword">AND</span> strUrl = <span class="string">'/api/t_service'</span>)</span><br></pre></td></tr></table></figure><p>好啦，这就实现了一个相对完整的分权分域的系统啦~</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><hr><p>整个鉴权过程是放在后台以中间件的形式存在的。所有发送的请求都要经过鉴权中间件才能继续往后走下去。</p><p>因此，除了在数据库层面进行设计以外，还要在后台代码进行一些必要性的优化。比如说有一类操作的对应权限是通用权限，这类接口占所有接口的一半以上。因此在鉴权中间件我会先判断一步是否为通用权限，若是则跳过接下来的鉴权，直接判过；不是的话再按照既定流程继续鉴权。</p><p>也可以在鉴权层增加日志打印，把所有经过鉴权的请求记录在案，以便日后追踪。</p><p>写到这里突然发现，我这个前端，越做越往后了…</p>]]></content>
    
    <summary type="html">
    
      最近要开发一个新的系统，系统里面可以有许多不同的社区，每个社区下面有不同的项目。项目和项目、社区和社区之间都是相互独立的。我所做的工作是设计一套权限管理系统，这套系统允许不同的用户在不同的社区或者项目之中有不同的权限，可以保证用户无法做出越权的操作。
    
    </summary>
    
    
      <category term="mysql" scheme="https://tuobaye0711.github.io/tags/mysql/"/>
    
      <category term="技术杂谈" scheme="https://tuobaye0711.github.io/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>使用Code-Printer生成一份炫酷的简历</title>
    <link href="https://tuobaye0711.github.io/2018/01/23/%E4%BD%BF%E7%94%A8code-printer%E7%94%9F%E6%88%90%E4%B8%80%E4%BB%BD%E7%82%AB%E9%85%B7%E7%9A%84%E7%AE%80%E5%8E%86/"/>
    <id>https://tuobaye0711.github.io/2018/01/23/使用code-printer生成一份炫酷的简历/</id>
    <published>2018-01-23T05:25:47.000Z</published>
    <updated>2018-03-04T15:08:12.821Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎光临我的博客<a href="http://tuobaye.com" target="_blank" rel="noopener">拓跋的前端客栈</a>，这个是<a href="http://tuobaye.com/2018/01/23/%E4%BD%BF%E7%94%A8code-printer%E7%94%9F%E6%88%90%E4%B8%80%E4%BB%BD%E7%82%AB%E9%85%B7%E7%9A%84%E7%AE%80%E5%8E%86/" target="_blank" rel="noopener">原文地址</a>，这个是<a href="https://github.com/tuobaye0711/code-printer" target="_blank" rel="noopener">项目地址</a>，欢迎star&amp;fork。如果您发现我文章中存在错误，请尽情向我吐槽，大家一起学习一起进步φ(&gt;ω&lt;*)</p><hr><h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><hr><p>最终效果请点击<strong><a href="http://tuobaye.com/demo/code-printer" target="_blank" rel="noopener">这里</a></strong>，是不是有点意思？</p><p><img src="/2018/01/23/使用code-printer生成一份炫酷的简历/code-printer.png" alt="code-printer.png"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><hr><p>code-printer的原理是首先搭起一个骨架，然后通过遍历的方式，一点一点地往骨架里塞东西。</p><p>骨架主要有三块：</p><ul><li>&lt;pre id=”my-code”&gt;: 主要用来展示的HTML代码的，带标签</li><li>&lt;style id=”style-elem”&gt;: 主要填CSS代码的，用于把&lt;pre&gt;里特定的标签转换成特定的样式</li><li>&lt;div id=”script-area”&gt;: 主要是填JS代码的。但是由于一个字符一个字符往里面填代码会出现大量报错，因此这部分需要一个段落的JS代码全部书写完毕以后，通过一个命令符’~’来一次性填入。</li></ul><h4 id="printCodes"><a href="#printCodes" class="headerlink" title="printCodes"></a><strong>printCodes</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> printCodes = <span class="function"><span class="keyword">function</span> (<span class="params">message, index, interval</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; message.length) &#123;</span><br><span class="line">        $code_pre.scrollTop = $code_pre.scrollHeight;</span><br><span class="line">        printChar(message[index++]);</span><br><span class="line">        <span class="keyword">return</span> setTimeout((<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> printCodes(message, index, interval);</span><br><span class="line">        &#125;), speed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码的主要作用就是遍历打印字符，同时每次打印的时候都将滚动条拖到最底下，保证用户能看到最新的变化。</p><h4 id="printChar"><a href="#printChar" class="headerlink" title="printChar"></a><strong>printChar</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> printChar = <span class="function"><span class="keyword">function</span> (<span class="params">which</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> char, formatted_code, prior_block_match, prior_comment_match, script_tag;</span><br><span class="line">    <span class="keyword">if</span> (which === <span class="string">"`"</span>) &#123;</span><br><span class="line">        <span class="comment">// 重置为空字符串，防止打印出来</span></span><br><span class="line">        which = <span class="string">""</span>;</span><br><span class="line">        isJs = !isJs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isJs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (which === <span class="string">"~"</span> &amp;&amp; !openComment) &#123;</span><br><span class="line">            script_tag = createElement(<span class="string">"script"</span>);</span><br><span class="line">            <span class="comment">// two matches based on prior scenario</span></span><br><span class="line">            prior_comment_match = <span class="regexp">/(?:\*\/([^\~]*))$/</span>;</span><br><span class="line">            prior_block_match = <span class="regexp">/([^~]*)$/</span>;</span><br><span class="line">            <span class="keyword">if</span> (unformatted_code.match(prior_comment_match)) &#123;</span><br><span class="line">                script_tag.innerHTML = unformatted_code.match(prior_comment_match)[<span class="number">0</span>].replace(<span class="string">"*/"</span>, <span class="string">""</span>) + <span class="string">"\n\n"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                script_tag.innerHTML = unformatted_code.match(prior_block_match)[<span class="number">0</span>] + <span class="string">"\n\n"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            $script_area.innerHTML = <span class="string">""</span>;</span><br><span class="line">            $script_area.appendChild(script_tag);</span><br><span class="line">        &#125;</span><br><span class="line">        char = which;</span><br><span class="line">        formatted_code = jsHighlight($code_pre.innerHTML, char);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        char = which === <span class="string">"~"</span> ? <span class="string">""</span> : which;</span><br><span class="line">        $style_elem.innerHTML += char;</span><br><span class="line">        formatted_code = cssHighlight($code_pre.innerHTML, char);</span><br><span class="line">    &#125;</span><br><span class="line">    prevAsterisk = which === <span class="string">"*"</span>;</span><br><span class="line">    prevSlash = (which === <span class="string">"/"</span>) &amp;&amp; !openComment;</span><br><span class="line">    openInteger = which.match(<span class="regexp">/[0-9]/</span>) || (openInteger &amp;&amp; which.match(<span class="regexp">/[\.\%pxems]/</span>)) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (which === <span class="string">'"'</span>) &#123;</span><br><span class="line">        openString = !openString;</span><br><span class="line">    &#125;</span><br><span class="line">    unformatted_code += which;</span><br><span class="line">    <span class="keyword">return</span> $code_pre.innerHTML = formatted_code;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>printChar</strong>函数是code-printer的核心函数，这个函数会根据当前的代码是JS还是CSS，来进行不同的处理。</p><p>如何判断是JS还是CSS代码呢？默认设置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isJs = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>也就是默认是CSS，然后以 <strong>`</strong> 作为切换符号，每次遇到 <strong>`</strong> 就切换一次语言。</p><p>当前字符属于JS时，在没遇到执行符号 <strong>~</strong> 之前，<strong>printChar</strong>只是单纯的打印格式化后的字符。遇到 <strong>~</strong> 以后，<strong>printChar</strong>进行了如下操作：</p><ol><li>函数首先通过正则匹配，匹配出之前的JS整段代码。</li><li>再调用<strong>createElement()</strong>来创造一对&lt;script&gt;&lt;/script&gt;标签，用来存放JS代码。</li><li>然后将处理过的JS代码存入&lt;script&gt;&lt;/script&gt;标签内。</li><li>最后通过<strong>$script_area.appendChild()</strong>的方式将&lt;script&gt;&lt;/script&gt;及其内部的JS代码存入&lt;div id=”script-area”&gt;中。注意，每次调用<strong>$script_area.appendChild()</strong>之前，都要将之前&lt;div id=”script-area”&gt;清空一遍，防止之前的JS代码再执行一次。</li></ol><p>当前字符属于CSS时，每次打印过程，一方面会将未格式化的字符串传入&lt;style id=”style-elem”&gt;中，用以生成样式。另一方面会将格式化的代码输出到&lt;pre id=”my-code”&gt;中，用以展示代码。</p><h4 id="cssHighlight和jsHighlight"><a href="#cssHighlight和jsHighlight" class="headerlink" title="cssHighlight和jsHighlight"></a><strong>cssHighlight</strong>和<strong>jsHighlight</strong></h4><p>这两个函数十分类似，主要作用就是通过正则匹配，给不同类型的字符两端封上不同的标签，用以高亮代码。举个栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (openInteger &amp;&amp; !which.match(<span class="regexp">/[0-9\.]/</span>) &amp;&amp; !openString &amp;&amp; !openComment) &#123;</span><br><span class="line">    s = string.replace(<span class="regexp">/([0-9\.]*)$/</span>, <span class="string">"&lt;em class=\"int\"&gt;$1&lt;/em&gt;"</span> + which);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一处典型的匹配+替换标签组合拳。作用是代码在以数字结尾时，给数字两端封上&lt;em class=”int”&gt;&lt;/em&gt;的标签。</p><p>代码中还有很多用作标志位的参数，比如说<strong>openInteger</strong>，表示这段输入都是数字。通过对这些控制位进行操作，可以将零散的字符分成一段一段的，方便进行处理。</p><p>其他部分就不谈了，自己可以看<a href="https://github.com/tuobaye0711/code-printer/blob/master/src/app.js" target="_blank" rel="noopener">源代码</a>，我已经加了备注。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><hr><p>您可以fork过去直接修改，也可以按照如下步骤操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/tuobaye0711/code-printer.git</span><br></pre></td></tr></table></figure><p>安装依赖文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>打包文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p>起服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run server</span><br></pre></td></tr></table></figure><p>修改配置说明：</p><p>resume 文件存放简历或者其他静态资源</p><p>source/code.js 存放需要打印并展示样式的代码（CSS/JS）</p><p>source/app.js 是主代码，可以修改一些比如说打印速度、高亮色等配置</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr><p>能在自己网站挂一份带打印特效的简历，想必能让人眼前一亮吧。这篇文章主要安利了一下我这个名为code-printer的小项目，希望能帮到各位~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎光临我的博客&lt;a href=&quot;http://tuobaye.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;拓跋的前端客栈&lt;/a&gt;，这个是&lt;a href=&quot;http://tuobaye.com/2018/01/23/%E4%BD%BF%E7%94
      
    
    </summary>
    
    
      <category term="CSS" scheme="https://tuobaye0711.github.io/tags/CSS/"/>
    
      <category term="JavaScript" scheme="https://tuobaye0711.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>3分钟搞懂CSS3 Transform属性</title>
    <link href="https://tuobaye0711.github.io/2018/01/17/3%E5%88%86%E9%92%9F%E6%90%9E%E6%87%82CSS3-transform%E5%B1%9E%E6%80%A7/"/>
    <id>https://tuobaye0711.github.io/2018/01/17/3分钟搞懂CSS3-transform属性/</id>
    <published>2018-01-17T06:59:34.000Z</published>
    <updated>2018-03-04T15:08:12.766Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎光临我的博客<a href="http://tuobaye.com" target="_blank" rel="noopener">拓跋的前端客栈</a>，这个是<a href="http://tuobaye.com/2018/01/17/3%E5%88%86%E9%92%9F%E6%90%9E%E6%87%82CSS3-transform%E5%B1%9E%E6%80%A7/" target="_blank" rel="noopener">原文地址</a>。如果您发现我文章中存在错误，请尽情向我吐槽，大家一起学习一起进步φ(&gt;ω&lt;*)</p><hr><blockquote><p>CSS transform 属性允许你修改CSS视觉格式模型的坐标空间。使用它，元素可以被转换（translate）、旋转（rotate）、缩放（scale）、倾斜（skew）。</p></blockquote><p>首先有个直观的印象，接下来放大招了~</p><p><img src="/2018/01/17/3分钟搞懂CSS3-transform属性/transform转换.png" alt="transform转换"></p><p>怎么样，是不是很直观？如果图片不清晰，在图片上点击右键-“在新标签页中打开图片”，然后在图片上点放大镜就可以查看原图了。</p><p>接下来有更直观的，我手写了一个简单的transform体验器，自己尝试一下吧：</p><p><a href="http://tuobaye.com/demo/transform" target="_blank" rel="noopener">transform体验器</a></p><p>不知道你搞懂了吗？</p><p>PS:</p><ul><li>transform是一个理解上很简单，使用起来却很有难度的属性。短时间内能理解80%就不错了，想完全掌握还需要多多练习。</li><li>本例中为了尽可能缩短篇幅，没有涉及到transform中matrix部分和rotate3d的部分，想要继续深入的话可以自行查找资料学习。</li><li>translateZ()是一个很特别的属性，需要结合perspective(透视)来理解。perspective可以简单理解为视点与屏幕之间的距离。当未设置perspective属性时，translateZ()的变化不会有任何影响。而设置perspective以后，translateZ()就符合“近大远小”的规律，Z轴上离你越近，图形显示越大。直到大过perspective值的时候，你就看不见了，这时候你就可以理解为元素到你“脑后”去了，人理所当然的看不见脑后的东西。</li><li>skew比较难搞懂，直接在图里用文字很难描述清楚。这里引用<a href="https://www.zhihu.com/question/21725826" target="_blank" rel="noopener">知乎-css3中-webkit-transform 的 skew 如何使用？</a>中Kori Lee的回复比较容易理解</li></ul><p><img src="/2018/01/17/3分钟搞懂CSS3-transform属性/skew.png" alt="skew"></p>]]></content>
    
    <summary type="html">
    
      transform是CSS3中非常有用的一个属性，今天我们就来挑战一下3分钟能否搞懂transform的基本用途吧~
    
    </summary>
    
    
      <category term="CSS" scheme="https://tuobaye0711.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>【Node.js线上部署小项目】让自己的博客每次打开都有不同的封面</title>
    <link href="https://tuobaye0711.github.io/2017/12/26/%E3%80%90Node.js%E7%BA%BF%E4%B8%8A%E9%83%A8%E7%BD%B2%E5%B0%8F%E9%A1%B9%E7%9B%AE%E3%80%91%E8%AE%A9%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%AF%8F%E6%AC%A1%E6%89%93%E5%BC%80%E9%83%BD%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B0%81%E9%9D%A2/"/>
    <id>https://tuobaye0711.github.io/2017/12/26/【Node.js线上部署小项目】让自己的博客每次打开都有不同的封面/</id>
    <published>2017-12-26T09:16:00.000Z</published>
    <updated>2020-02-05T06:56:14.733Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎光临我的博客<a href="http://tuobaye.com" target="_blank" rel="noopener">拓跋的前端客栈</a>，这个是<a href="http://tuobaye.com/2017/12/26/%E3%80%90Node.js%E7%BA%BF%E4%B8%8A%E9%83%A8%E7%BD%B2%E5%B0%8F%E9%A1%B9%E7%9B%AE%E3%80%91%E8%AE%A9%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%AF%8F%E6%AC%A1%E6%89%93%E5%BC%80%E9%83%BD%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B0%81%E9%9D%A2/" target="_blank" rel="noopener">原文地址</a>，这个是<a href="https://github.com/tuobaye0711/new-wallpaper-everyday" target="_blank" rel="noopener">项目地址</a>，这个是<a href="http://tuobaye.duapp.com/" target="_blank" rel="noopener">线上部署地址</a>。如果您发现我文章中存在错误，请尽情向我吐槽，大家一起学习一起进步φ(&gt;ω&lt;*)</p><h2 id="1、引子"><a href="#1、引子" class="headerlink" title="1、引子"></a>1、引子</h2><hr><p>为什么想做这个功能呢？起因很简单————我看腻了自己博客的封面(特地要提一下，封面是来自<a href="https://github.com/letiantian/huno" target="_blank" rel="noopener">huno</a>)。</p><p><img src="/2017/12/26/【Node.js线上部署小项目】让自己的博客每次打开都有不同的封面/background-cover.jpg" alt="old cover"></p><p>虽然我的封面很好看的说，但是谁还没有个审美疲劳不是？</p><p>毕竟再好看的图片都有看腻的一天，为了克服审美疲劳，最好能经常换换封面，每天都不一样就更好了！</p><p>想到了就去做，动手~</p><h2 id="2、选图源"><a href="#2、选图源" class="headerlink" title="2、选图源"></a>2、选图源</h2><hr><p>说起每天一张美图，那大伙第一个想到的肯定是<a href="https://www.bing.com" target="_blank" rel="noopener">必应</a>啦，必应的搜索引擎虽然大多数人用的不多——翻墙的用谷歌的多，不翻墙的用百度的多。但是必应搜索的首页真的很亮眼~就是因为每天都有不同的美图做背景，而且根据地理位置还有不同的图片：</p><p><img src="/2017/12/26/【Node.js线上部署小项目】让自己的博客每次打开都有不同的封面/bingcn.png" alt="bingcn"><br><img src="/2017/12/26/【Node.js线上部署小项目】让自己的博客每次打开都有不同的封面/bingen.png" alt="bingen"></p><p>既美又高清，很适合做壁纸。就是他了！</p><p>既然要做接，首先要抓取bing的api，emmm，打开bing主页，F12，点击Network-XHR，挨个找一下，很容易就能发现在哪里，看图~</p><p><img src="/2017/12/26/【Node.js线上部署小项目】让自己的博客每次打开都有不同的封面/xhr.png" alt="xhr"></p><p>很容易找到是哪条请求。其实这个bing的壁纸接口在网上一搜也能搜到了，<a href="https://stackoverflow.com/questions/10639914/is-there-a-way-to-get-bings-photo-of-the-day" target="_blank" rel="noopener">看这里</a>。</p><p> 接口格式是这样的：</p><blockquote><p>XML: <a href="http://www.bing.com/HPImageArchive.aspx?format=xml&amp;idx=0&amp;n=1&amp;mkt=en-US" target="_blank" rel="noopener">http://www.bing.com/HPImageArchive.aspx?format=xml&amp;idx=0&amp;n=1&amp;mkt=en-US</a><br>JSON: <a href="http://www.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&amp;mkt=en-US" target="_blank" rel="noopener">http://www.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&amp;mkt=en-US</a><br>RSS: <a href="http://www.bing.com/HPImageArchive.aspx?format=rss&amp;idx=0&amp;n=1&amp;mkt=en-US" target="_blank" rel="noopener">http://www.bing.com/HPImageArchive.aspx?format=rss&amp;idx=0&amp;n=1&amp;mkt=en-US</a></p></blockquote><ul><li><em>format</em>表示返回格式，可选字段有xml、js（json）、rss</li><li><em>idx</em>=x表示获取从第x天前开始的图片，最大值为7，n&gt;7时返回的都是n=7的值</li><li><em>n</em>=y表示获取从idx开始连续y天的图片，最大值为9，同时限制最多能获取15天以内的图片</li><li><em>mkt</em>表示地区信息，已知的只有zh-CN和en-US，是否还有其他的我也不清楚</li></ul><p>返回值如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"images"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"startdate"</span>: <span class="string">"20171226"</span>, </span><br><span class="line">            <span class="string">"fullstartdate"</span>: <span class="string">"201712261600"</span>, </span><br><span class="line">            <span class="string">"enddate"</span>: <span class="string">"20171227"</span>, </span><br><span class="line">            <span class="string">"url"</span>: <span class="string">"/az/hprichbg/rb/CPNYSnow_ZH-CN13335620157_1920x1080.jpg"</span>, </span><br><span class="line">            <span class="string">"urlbase"</span>: <span class="string">"/az/hprichbg/rb/CPNYSnow_ZH-CN13335620157"</span>, </span><br><span class="line">            <span class="string">"copyright"</span>: <span class="string">"中央公园，美国纽约市 (© Nisian Hughes/Getty Images)"</span>, </span><br><span class="line">            <span class="string">"copyrightlink"</span>: <span class="string">"http://www.bing.com/search?q=%E4%B8%AD%E5%A4%AE%E5%85%AC%E5%9B%AD&amp;form=hpcapt&amp;mkt=zh-cn"</span>, </span><br><span class="line">            <span class="string">"quiz"</span>: <span class="string">"/search?q=Bing+homepage+quiz&amp;filters=WQOskey:%22HPQuiz_20171226_CPNYSnow%22&amp;FORM=HPQUIZ"</span>,</span><br><span class="line">            <span class="string">"wp"</span>: <span class="literal">true</span>, </span><br><span class="line">            <span class="string">"hsh"</span>: <span class="string">"381850a3d2d57acd0ded240e42ffec8e"</span>, </span><br><span class="line">            <span class="string">"drk"</span>: <span class="number">1</span>, </span><br><span class="line">            <span class="string">"top"</span>: <span class="number">1</span>, </span><br><span class="line">            <span class="string">"bot"</span>: <span class="number">1</span>, </span><br><span class="line">            <span class="string">"hs"</span>: [ ]</span><br><span class="line">        &#125;</span><br><span class="line">    ], </span><br><span class="line">    <span class="string">"tooltips"</span>: &#123;</span><br><span class="line">        <span class="string">"loading"</span>: <span class="string">"正在加载..."</span>, </span><br><span class="line">        <span class="string">"previous"</span>: <span class="string">"上一个图像"</span>, </span><br><span class="line">        <span class="string">"next"</span>: <span class="string">"下一个图像"</span>, </span><br><span class="line">        <span class="string">"walle"</span>: <span class="string">"此图片不能下载用作壁纸。"</span>, </span><br><span class="line">        <span class="string">"walls"</span>: <span class="string">"下载今日美图。仅限用作桌面壁纸。"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只要在 <a href="http://www.bing.com" target="_blank" rel="noopener">www.bing.com</a> 后面拼上images[0].url就是我们想要的图片的链接了~还是1920x1080的高清图片呢，拿来做壁纸正合适~</p><p>有了这些已知信息，我们终于可以愉快的撸代码了φ(&gt;ω&lt;*)</p><h2 id="3、撸代码"><a href="#3、撸代码" class="headerlink" title="3、撸代码"></a>3、撸代码</h2><hr><p>我选择采用Node.js+express来搭建我们的后台代码。并做一个规划，我们的接口要能返回当日的图片，能根据入参返回几天前的哪个地区的图片，哦对了，能随机返回图片，保证咱每次看到的都不一样。</p><p>很简单，说干就干。</p><p>关于怎么搭建一个Node.js+express服务我就不废话了，这几个接口都要用到请求uri，简单写个公共函数用来获取uri：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUri</span>(<span class="params">start, number, mkt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'https://www.bing.com/HPImageArchive.aspx?format=js&amp;idx='</span> + start + <span class="string">'&amp;n='</span> + number + <span class="string">'&amp;mkt='</span> + mkt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外由于获取随机图片和获取按参数指定的图片肯定是两个不同的接口，但是他们同时要用到一个请求并处理返回值的过程，为了代码好看，我们把他抽离出来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWallpaper</span>(<span class="params">res, days_ago, mkt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> uri;</span><br><span class="line">    <span class="keyword">if</span> (days_ago &lt;= <span class="number">7</span>)&#123;</span><br><span class="line">        uri = getUri(days_ago, <span class="number">1</span>, mkt)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        uri = getUri(<span class="number">7</span>, days_ago<span class="number">-6</span>, mkt)</span><br><span class="line">    &#125;</span><br><span class="line">    request(uri, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!error &amp;&amp; response.statusCode === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(body);</span><br><span class="line">            <span class="keyword">let</span> images = data.images;</span><br><span class="line">            res.redirect(<span class="string">'https://www.bing.com'</span>+images[images.length<span class="number">-1</span>].url)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.send(<span class="string">'request error!'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数很简单，看一眼就明白了，至于为什么返回的时候使用res.redirect()，这跟我的目的有关系。</p><p>我一开始就提到了，我要实现自己博客每天更换封面的效果，博客的封面使用的是CSS的background样式，这个样式虽然可以用本地图片也可以用线上图片，但是必须是图片！由于我们的服务自己不做存储，因此直接把要获取到的图片的根地址返回过去才是最优解，这就是我们选择使用res.redirect()的原因。</p><p>还有随机接口，我们只要写个自定义范围的随机函数打乱就可以了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomInteger</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)) + min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数getRandomInteger(min, max)返回min和max之间的任意整数。使用这个函数不仅可以随机获取0-15天内的某个天数，也可以使用ta获取随机的地区：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mkt = getRandomInteger(<span class="number">0</span>,<span class="number">1</span>) ? <span class="string">'zh-CN'</span> : <span class="string">'en-US'</span>;</span><br></pre></td></tr></table></figure><p>其他都没什么难度了，就是传参。可以自己去看<a href="https://github.com/tuobaye0711/new-wallpaper-everyday" target="_blank" rel="noopener">源码</a>~</p><h2 id="4、BAE线上部署"><a href="#4、BAE线上部署" class="headerlink" title="4、BAE线上部署"></a>4、BAE线上部署</h2><hr><p>既然我们自己写的接口希望能用在自己的个人网站上，接口肯定不能只能在本地调用吧？我们接下来要做的就是把博客线上部署啦，这样我们就能把接口暴露在互联网上，造福自己，造福大家~</p><p>因为我们的项目相当之轻量，不占存储，不占内存，基本上就是做一个转发的功能，因此不需要什么很高的服务器性能。为了这个项目还要自己租用一个云服务器那就得不偿失了~在你自己本身没有服务器的前提下，我推荐你使用百度的BAE进行线上部署(Baidu Application Engine)，一天只要两毛钱，用到天长地久（我都有点替百度心疼资源o(TωT)o ）。 </p><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><ol><li>首先登陆<a href="https://console.bce.baidu.com" target="_blank" rel="noopener">百度云</a>的首页，没有注册的注册一下，注册以后实名认证一下。这里不细说了~</li><li>点击左侧菜单栏的应用引擎BAE，界面如图所示，点击“添加部署”。<img src="/2017/12/26/【Node.js线上部署小项目】让自己的博客每次打开都有不同的封面/step2.png" alt="step2"></li><li>界面如图所示，按你的需要选择配置，我选择的是这样的（请无视右侧的重叠框，滚动截图工具不支持position: fixed定位方式的锅）。其中，由于我要跑的是Node.js代码，因此类型选择Node能支持的最高版本。代码版本工具依靠个人喜好，我喜欢git。内存选最低，单元个数选最少，OK，一天只需要两毛钱~点击下一步。<img src="/2017/12/26/【Node.js线上部署小项目】让自己的博客每次打开都有不同的封面/step3.png" alt="step3"></li><li>点击“去支付”即可，后付费方式，账号里没有余额也能支付成功。<img src="/2017/12/26/【Node.js线上部署小项目】让自己的博客每次打开都有不同的封面/step4.png" alt="step4"></li><li>OK,开通成功了，去控制台看看吧~<img src="/2017/12/26/【Node.js线上部署小项目】让自己的博客每次打开都有不同的封面/step5.png" alt="step5"></li><li>在部署列表里，直接点名称进到里面，选择发布设置。这里可以看到git地址，我们这就可以通过git clone的方式把代码库同步到本地，然后把本地的代码放到里面，push上来，就大功告成啦~对了，最好把自动发布设置打开，这样每次更新代码都能自动在线上部署最新的版本咯。<img src="/2017/12/26/【Node.js线上部署小项目】让自己的博客每次打开都有不同的封面/step6-1.png" alt="step6-1"> <img src="/2017/12/26/【Node.js线上部署小项目】让自己的博客每次打开都有不同的封面/step6-2.png" alt="step6-2"></li><li>最后，调用一下我的接口试试吧：tuobaye.duapp.com</li></ol><h3 id="BAE部署过程中的几个坑"><a href="#BAE部署过程中的几个坑" class="headerlink" title="BAE部署过程中的几个坑"></a>BAE部署过程中的几个坑</h3><ol><li>BAE代码只能监听18080，要把原来的端口设置改为18080；</li><li>BAE默认不支持ES6语法，所以原来你代码里的let/const什么的老老实实改成var吧，</li><li>我在上传的过程中，把node_modules省略了，然后在package.json里面写上了dependencies，但是报错了。我的解决办法是直接把node_modules上传，把package.json的dependencies删掉，只让他自动执行启动脚本，不管别的，就启动成功了。</li><li><a href="https://cloud.baidu.com/doc/BAE/Nodejs.html" target="_blank" rel="noopener">BAE文档</a>，有其他问题可以看看这个，有一定参考价值。</li></ol><p>OK，搞定啦</p><h2 id="5、修改背景，目的达成！"><a href="#5、修改背景，目的达成！" class="headerlink" title="5、修改背景，目的达成！"></a>5、修改背景，目的达成！</h2><p>我的博客是用hexo生成的，博客的背景图片在主题文件的样式里面。每个人都有自己的不同情况，但是只要找到这一行样式就行了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.panel-cover</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">900</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: none;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(../images/background-cover.jpg) top left no-repeat <span class="number">#666666</span>;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把background改成我们自己的接口，这个接口可以获取当天的壁纸图片：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.panel-cover</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">900</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: none;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(http://tuobaye.duapp.com/wallpaper) top left no-repeat <span class="number">#666666</span>;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下，是不是很有成就感~？</p><p><img src="/2017/12/26/【Node.js线上部署小项目】让自己的博客每次打开都有不同的封面/before.png" alt="before"><br><img src="/2017/12/26/【Node.js线上部署小项目】让自己的博客每次打开都有不同的封面/after.png" alt="after"></p><p>如果把url换成 <a href="http://tuobaye.duapp.com/wallpaper/random" target="_blank" rel="noopener">http://tuobaye.duapp.com/wallpaper/random</a> ，就可以每刷新一次都是新的封面了~帅气！</p><p>PS. 现在我有自己的服务器了，已经不用BAE了。BAE基础版好像马上就要下线了（貌似太便宜了赚不到钱…）。如果想调用我的api，只需把url换成<a href="https://api.tuobaye.com/wallpaper/random" target="_blank" rel="noopener">https://api.tuobaye.com/wallpaper/random</a>即可~</p><h2 id="6、小结"><a href="#6、小结" class="headerlink" title="6、小结"></a>6、小结</h2><hr><p>看完这篇文章，你将会从零开始学会写一个实用的小项目，然后在线上部署，在相当低成本的情况下将自己的接口暴露出去，造福自己，造福别人~</p><p>从想到换封面的点子，到选图源，抓接口，撸代码，BAE部署到最后自己用上自己最新鲜的接口，实际的工作量一共也不超过一天时间，其中还有一大半时间都是在踩BAE的坑。</p><p>很多时候，限制我们的并不是我们的技术，而是创意和实干的心。</p><p>虽然项目简单，但是能对读到这里的读者一点启发作用，那我觉得就很知足了~</p><p>想到就去做，Just do it!</p>]]></content>
    
    <summary type="html">
    
      是不是看腻了自己博客的背景图片？赶紧来自己动手做一个吧！看完这篇文章，你将会从零开始学会写一个实用的小项目，然后在线上部署，在相当低成本的情况下将自己的接口暴露出去，造福自己，造福别人~
    
    </summary>
    
    
      <category term="Node.js" scheme="https://tuobaye0711.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Web超时配置总结</title>
    <link href="https://tuobaye0711.github.io/2017/12/19/web%E8%B6%85%E6%97%B6%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/"/>
    <id>https://tuobaye0711.github.io/2017/12/19/web超时配置总结/</id>
    <published>2017-12-19T11:54:22.000Z</published>
    <updated>2018-03-04T15:08:12.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><hr><p>前段时间做项目时，由于某个请求在后台要进行长时间的脚本处理，频频超出系统默认的超时时长，于是我就对超时时长进行了检查。由于超时的时候请求报错的提示信息并不明确，为了修改这玩意儿也查了一堆资料，忙活了半天，终于把超时问题解决了，在这里做个记录。</p><p>我的项目用的是web前台（这个无所谓用的什么框架，反正归根结底是js）+nginx代理+Node.js后台搭建的，我发现每一节都设了一道timeout超时的关卡，也就是说有<strong>客户端超时</strong>，<strong>代理超时</strong>，<strong>服务端超时</strong>三种情况。下面针对每种超时，我将进行分别讲解。</p><p><img src="/2017/12/19/web超时配置总结/timeout.jpg" alt="timeout!"></p><h2 id="客户端超时"><a href="#客户端超时" class="headerlink" title="客户端超时"></a>客户端超时</h2><hr><h3 id="XMLHttpRequest的超时设置"><a href="#XMLHttpRequest的超时设置" class="headerlink" title="XMLHttpRequest的超时设置"></a>XMLHttpRequest的超时设置</h3><p>讲客户端超时，就要从XMLHttpRequest来谈起。</p><p>XMLHttpRequest是一个API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过URL来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest在AJAX中被大量使用。</p><p>XMLHttpRequest一开始只是微软浏览器提供的一个接口，后来各大浏览器纷纷效仿也提供了这个接口，再后来W3C对它进行了标准化，提出了XMLHttpRequest标准。XMLHttpRequest标准又分为Level 1和Level 2。<br>XMLHttpRequest Level 1主要存在以下缺点：</p><ul><li>受同源策略的限制，不能发送跨域请求；</li><li>不能发送二进制文件（如图片、视频、音频等），只能发送纯文本数据；</li><li>在发送和获取数据的过程中，无法实时获取进度信息，只能判断是否完成；</li></ul><p>那么Level 2对Level 1 进行了改进，XMLHttpRequest Level 2中新增了以下功能：</p><ul><li>可以发送跨域请求，在服务端允许的情况下；</li><li>支持发送和接收二进制数据；</li><li>新增formData对象，支持发送表单数据；</li><li>发送和获取数据时，可以获取进度信息；</li><li>可以设置请求的超时时间；</li></ul><p>在Level 2版本的XMLHttpRequest对象，增加了timeout属性，可以设置HTTP请求的时限。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xhr.timeout = <span class="number">60</span>*<span class="number">1000</span>;</span><br><span class="line">xhr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">　　　　alert(<span class="string">'timeout！'</span>);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，请求超时时间被设为1分钟（xhr.timeout的单位是毫秒），如果超过1分钟的时限，则会自动停止http请求；同时，触发ontimeout事件，弹出“timeout！”的提示框。</p><p>同时值得注意的一点是，超时时间的计算，是从调用xhr.send()开始，至xhr.loadend触发为止的这段时间。即时xhr.timeout的设置是在xhr.send()之后，timeout的计时起点仍为调用xhr.send()的时刻。</p><h3 id="其他超时设置"><a href="#其他超时设置" class="headerlink" title="其他超时设置"></a>其他超时设置</h3><p>其实会了XMLHttpRequest的超时设置，其他前端的框架啊、工具啊的超时设置都不再是问题，这就有点万法归宗的意思。因为我们常用的jQuery.ajax()方法实际上就是对浏览器提供的XMLHttpRequest对象的封装。而又有很多其他框架或者工具的请求模块是对jQuery.ajax()的封装。说到底，都是依赖的XMLHttpRequest对象。因此掌握了XMLHttpRequest，其他都很好学会。</p><p>依jQuery.ajax()的超时设置为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">"test.html"</span>,</span><br><span class="line">    error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// will fire when timeout is reached</span></span><br><span class="line">    &#125;,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;,</span><br><span class="line">    timeout: <span class="number">60</span>*<span class="number">1000</span> <span class="comment">// sets timeout to 1 minute</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>实在是简单，对不对？</p><h2 id="代理超时"><a href="#代理超时" class="headerlink" title="代理超时"></a>代理超时</h2><hr><p>nginx的超时设置主要分3种：</p><ul><li>proxy_connect_timeout</li><li>proxy_read_timeout</li><li>proxy_send_timeout</li></ul><h3 id="proxy-connect-timeout"><a href="#proxy-connect-timeout" class="headerlink" title="proxy_connect_timeout"></a>proxy_connect_timeout</h3><blockquote><p>语法: proxy_connect_timeout timeout_in_seconds<br>上下文: http, server, location<br>默认值: 60s</p></blockquote><p>proxy_connect_timeout是和后端建立连接的超时时间。需要记住的是，这个时间不能超过75秒。</p><p>这个不是等待后端返回页面的时间，那是由proxy_read_timeout声明的。如果你的upstream服务器起来了，但是挂起了（例如，没有足够的线程处理请求，所以把你的请求放到请求池里稍后处理），那么这个声明是没有用的，由于与upstream服务器的连接已经建立了。</p><h3 id="proxy-read-timeout"><a href="#proxy-read-timeout" class="headerlink" title="proxy_read_timeout"></a>proxy_read_timeout</h3><blockquote><p>语法: proxy_read_timeout the_time<br>上下文: http, server, location<br>默认值: 60s</p></blockquote><p>proxy_read_timeout是从后端读取数据的超时时间，两次读取操作的时间间隔如果大于这个值，和后端的连接会被关闭。如果一个请求时间时间非常大，要把这个值设大点。</p><h3 id="proxy-send-timeout"><a href="#proxy-send-timeout" class="headerlink" title="proxy_send_timeout"></a>proxy_send_timeout</h3><blockquote><p>语法: proxy_send_timeout time<br>上下文: http, server, location<br>默认值: 60s</p></blockquote><p>proxy_send_timeout是向后端写数据的超时时间，两次写操作的时间间隔大于这个值，也就是过了这么长时间后端还是没有收到数据，连接会被关闭。</p><h2 id="服务端超时"><a href="#服务端超时" class="headerlink" title="服务端超时"></a>服务端超时</h2><hr><p>Node.js做服务器时，默认的超时时长为2分钟。假设请求发送到服务端，在2分钟内没有响应返回给客户端，客户端的链接就会被重置。这个时长的设置是很必要的，因为过长的请求响应会阻塞IO，造成极差的用户体验。特别对于Node.js这种单线程应用来说，影响可以说是灾难性的，因此如何设置服务端的超时时间也是非常关键的。</p><p>服务端超时设置也不是一刀切的，总体来说，有一个总开关，还可以对每个服务端的请求或者响应单独设置超时时长。</p><p>我们后面的代码均以Node.js+Express搭建的后台为例。</p><h3 id="服务端超时总开关"><a href="#服务端超时总开关" class="headerlink" title="服务端超时总开关"></a>服务端超时总开关</h3><p>使用Node.js的http模块启动服务器，并设置超时时长：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(./config);</span><br><span class="line"></span><br><span class="line">process.env.PORT = config.webport || <span class="number">8888</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"><span class="keyword">let</span> server = app.listen(process.env.PORT);</span><br><span class="line">server.setTimeout(<span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">server.on(<span class="string">'timeout'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout!'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>server.setTimeout()是设置server的超时时间设置方法，单位是毫秒，一旦超过设置的超时时长，则触发server对象的’timeout’事件，并传入socket作为一个参数。</p><h3 id="设置Express中间件超时时间"><a href="#设置Express中间件超时时间" class="headerlink" title="设置Express中间件超时时间"></a>设置Express中间件超时时间</h3><blockquote><p>Express是一个路由和中间件Web框架，其自身只具有最低程度的功能：Express应用程序基本上是一系列中间件函数调用。</p></blockquote><blockquote><p>中间件函数能够访问请求对象 (req)、响应对象 (res) 以及应用程序的请求/响应循环中的下一个中间件函数。下一个中间件函数通常由名为 next 的变量来表示。</p></blockquote><blockquote><p>中间件函数可以执行以下任务：</p></blockquote><blockquote><ul><li>执行任何代码。</li><li>对请求和响应对象进行更改。</li><li>结束请求/响应循环。</li><li>调用堆栈中的下一个中间件函数。</li></ul></blockquote><blockquote><p>如果当前中间件函数没有结束请求/响应循环，那么它必须调用next()，以将控制权传递给下一个中间件函数。否则，请求将保持挂起状态。</p></blockquote><p>对于Express的中间件，我们可以在app.js里为每个路由及其处理程序函数的中间件设置请求的响应和超时时间，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/user/:id'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 设置该中间件下所有HTTP请求的超时时间</span></span><br><span class="line">    req.setTimeout(<span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 设置该中间件下所有HTTP请求的服务器响应超时时间</span></span><br><span class="line">    res.setTimeout(<span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">    res.send(<span class="string">'USER'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Express不仅可以针对中间件设置超时时间，还可以针对某个具体的接口设置请求和响应的超时时长：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/user/:id'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 设置该接口下所有HTTP请求的超时时间</span></span><br><span class="line">    req.setTimeout(<span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 设置该接口下所有HTTP请求的服务器响应超时时间</span></span><br><span class="line">    res.setTimeout(<span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">    res.send(<span class="string">'USER'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>全写完了以后，仔细想了想，发现还没有写全，比如说服务端也可以发请求，不管是用http.method还是用request模块，都可以发请求。由于Node.js在很多项目中都是作为中间层，不管是向JAVA后台请求数据，还是用作解决客户端跨域问题的请求中转层，发请求都是很常用的用法。但是只要读者能耐心读到这里，相信随手网上搜一下就知道怎么写了，因此我这里就不再赘述了。</p><p>写这篇文章主要想分享一下我的感受，超时限制就像一道关卡，一个请求从客户端到服务端，再从服务端返回客户端的路上，要“过五关斩六将”。有的时候想要修改超时设置，可能不是简单修改某一处就能解决问题的，这时候一定要仔细检查，把这个系统理一遍，每一个地方的超时设置都看一看，才能解决问题~</p>]]></content>
    
    <summary type="html">
    
      前段时间做项目时，由于某个请求在后台要进行长时间的脚本处理，频频超出系统默认的超时时长，于是我就对超时时长进行了检查。由于超时的时候请求报错的提示信息并不明确，为了修改这玩意儿也查了一堆资料，忙活了半天，终于把超时问题解决了，分享在这里供大家参考。
    
    </summary>
    
    
      <category term="Nginx" scheme="https://tuobaye0711.github.io/tags/Nginx/"/>
    
      <category term="JavaScript" scheme="https://tuobaye0711.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://tuobaye0711.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>谈一谈大文件上传——前台分片和后台合并</title>
    <link href="https://tuobaye0711.github.io/2017/12/01/%E8%B0%88%E4%B8%80%E8%B0%88%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%89%8D%E5%8F%B0%E5%88%86%E7%89%87%E5%92%8C%E5%90%8E%E5%8F%B0%E5%90%88%E5%B9%B6/"/>
    <id>https://tuobaye0711.github.io/2017/12/01/谈一谈大文件上传——前台分片和后台合并/</id>
    <published>2017-12-01T09:26:35.000Z</published>
    <updated>2018-03-04T15:08:12.827Z</updated>
    
    <content type="html"><![CDATA[<p>最近做了一个需求，需要上传镜像的tar包，小的3、5G，大的可能会达到20多G，而要求在浏览器中上传，因此普通的上传方式肯定无法满足需求，必须要使用到分片上传，前台分片后台就需要合并，一系列做完以后踩了很多坑，在这边总结记录一下。</p><h2 id="前台分片上传"><a href="#前台分片上传" class="headerlink" title="前台分片上传"></a>前台分片上传</h2><hr><p>所谓上传，实际上就是一个把文件通过客户端传给服务端的过程，也就是通过前端传给后台的过程。在这个过程中，如果要传输的内容太过庞大，在传输过程中就容易遇到各种各样的问题。为了把出现问题的概率控制在最低，我们往往需要把大文件分成一份一份的小文件来依次上传，这个过程就是我们所说分片上传。</p><p>我前台使用的是webuploader上传插件，参考webuploader的切片方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CuteFile</span>(<span class="params"> file, chunkSize </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pending = [],</span><br><span class="line">        blob = file.source,</span><br><span class="line">        total = blob.size,</span><br><span class="line">        chunks = chunkSize ? <span class="built_in">Math</span>.ceil( total / chunkSize ) : <span class="number">1</span>,</span><br><span class="line">        start = <span class="number">0</span>,</span><br><span class="line">        index = <span class="number">0</span>,</span><br><span class="line">        len, api;</span><br><span class="line"></span><br><span class="line">    api = &#123;</span><br><span class="line">        file: file,</span><br><span class="line"></span><br><span class="line">        has: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> !!pending.length;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        shift: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pending.shift();</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        unshift: <span class="function"><span class="keyword">function</span>(<span class="params"> block </span>) </span>&#123;</span><br><span class="line">            pending.unshift( block );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( index &lt; chunks ) &#123;</span><br><span class="line">        len = <span class="built_in">Math</span>.min( chunkSize, total - start );</span><br><span class="line"></span><br><span class="line">        pending.push(&#123;</span><br><span class="line">            file: file,</span><br><span class="line">            start: start,</span><br><span class="line">            end: chunkSize ? (start + len) : total,</span><br><span class="line">            total: total,</span><br><span class="line">            chunks: chunks,</span><br><span class="line">            chunk: index++,</span><br><span class="line">            cuted: api</span><br><span class="line">        &#125;);</span><br><span class="line">        start += len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file.blocks = pending.concat();</span><br><span class="line">    file.remaning = pending.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> api;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，chunkSize表示每片大小，chunks表示切片的数目，具体切分方法也很简单，看代码就好了。</p><p>具体在使用webuploader的过程中，只需要在创建webuploader实例的过程中如下配置一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uploader = WebUploader.create(&#123;</span><br><span class="line">    <span class="comment">// 文件接收服务端。</span></span><br><span class="line">    server: <span class="string">'./ftp/images'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择文件的按钮。可选。</span></span><br><span class="line">    <span class="comment">// 内部根据当前运行是创建，可能是input元素，也可能是flash.</span></span><br><span class="line">    pick: <span class="string">'#picker'</span>,</span><br><span class="line"></span><br><span class="line">    chunked: <span class="literal">true</span>,<span class="comment">//开启分片上传</span></span><br><span class="line">    chunkSize: <span class="number">50</span>*<span class="number">1024</span>*<span class="number">1024</span>,<span class="comment">//每片大小50M</span></span><br><span class="line">    chunkRetry: <span class="number">1</span>,<span class="comment">//失败后重试次数</span></span><br><span class="line">    threads: <span class="number">1</span>,<span class="comment">//上传并发数目</span></span><br><span class="line">    fileNumLimit: <span class="number">1</span>,<span class="comment">//验证文件总数量，超出则不允许加入队列</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="后台合并"><a href="#后台合并" class="headerlink" title="后台合并"></a>后台合并</h2><hr><p>对于分片上传上来的文件，后台肯定要再次合并起来，重新生成跟原文件一模一样的文件。后台合并的方法有很多，以Node.js为例，可以使用以下方式：</p><h3 id="buffer合并"><a href="#buffer合并" class="headerlink" title="buffer合并"></a>buffer合并</h3><p>按照惯例，先贴代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并分片</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeChunks</span>(<span class="params">fileName, chunks, callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'chunks:'</span> + chunks);</span><br><span class="line">    <span class="keyword">let</span> chunkPaths = chunks.map(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> path.join(process.env.IMAGESDIR, name)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采用Buffer方式合并</span></span><br><span class="line">    <span class="keyword">const</span> readStream = <span class="function"><span class="keyword">function</span> (<span class="params">chunkArray, cb</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> buffers = [];</span><br><span class="line">        chunkPaths.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> buffer = fs.readFileSync(path);</span><br><span class="line">            buffers.push(buffer);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> concatBuffer = Buffer.concat(buffers);</span><br><span class="line">        <span class="keyword">let</span> concatFilePath = path.join(process.env.IMAGESDIR, fileName);</span><br><span class="line">        fs.writeFileSync(concatFilePath, concatBuffer);</span><br><span class="line"></span><br><span class="line">        chunkPaths.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">            fs.unlinkSync(path)</span><br><span class="line">        &#125;)</span><br><span class="line">        cb();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    readStream(chunkPaths, callback);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buffer方式合并是一种常见的文件合并方式，方法是将各个分片文件分别用fs.readFile()方式读取，然后通过Buffer.concat()进行合并。</p><p>这种方法简单易理解，但有个最大的缺点，就是你读取的文件有多大，合并的过程占用的内存就有多大，因为我们相当于把这个大文件的全部内容都一次性载入到内存中了，这是非常低效的。同时，Node默认的缓冲区大小的上限是2GB，一旦我们上传的大文件超出2GB，那使用这种方法就会失败。虽然可以通过修改缓冲区大小上限的方法来规避这个问题，但是鉴于这种合并方式极吃内存，我不建议您这么做。</p><p>那么，有更好的方式吗？那是当然，下面介绍一种stream合并方式。</p><h3 id="stream合并"><a href="#stream合并" class="headerlink" title="stream合并"></a>stream合并</h3><p>显然，stream（流，下面都用‘流’来表示stream）就是这种更好的方式。</p><p>按照惯例，先贴代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并分片</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeChunks</span>(<span class="params">fileName, chunks, callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'chunks:'</span> + chunks);</span><br><span class="line">    <span class="keyword">let</span> chunkPaths = chunks.map(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> path.join(process.env.IMAGESDIR, name)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采用Stream方式合并</span></span><br><span class="line">    <span class="keyword">let</span> targetStream = fs.createWriteStream(path.join(process.env.IMAGESDIR, fileName));</span><br><span class="line">    <span class="keyword">const</span> readStream = <span class="function"><span class="keyword">function</span> (<span class="params">chunkArray, cb</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> path = chunkArray.shift();</span><br><span class="line">        <span class="keyword">let</span> originStream = fs.createReadStream(path);</span><br><span class="line">        originStream.pipe(targetStream, &#123;<span class="attr">end</span>: <span class="literal">false</span>&#125;);</span><br><span class="line">        originStream.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 删除文件</span></span><br><span class="line">            fs.unlinkSync(path);</span><br><span class="line">            <span class="keyword">if</span> (chunkArray.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                readStream(chunkArray, callback)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cb()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    readStream(chunkPaths, callback);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么说流更好呢？流到底是什么呢？"><a href="#为什么说流更好呢？流到底是什么呢？" class="headerlink" title="为什么说流更好呢？流到底是什么呢？"></a>为什么说流更好呢？流到底是什么呢？</h4><p>流是数据的集合 —— 就像数组或字符串一样。区别在于流中的数据可能不会立刻就全部可用，并且你无需一次性的把这些数据全部放入内存。这使得流在操作大量数据或是数据从外部来源逐段发送过来的时候变得非常有用。</p><p>换句话说，当你使用buffer方式来处理一个2GB的文件，占用的内存可能是2GB以上，而当你使用流来处理这个文件，可能只会占用几十个M。这就是我们为什么选择流的原因所在。</p><p>在Node.js中，有4种基本类型的流，分别是可读流，可写流，双向流以及变换流。</p><ul><li>可读流是对一个可以读取数据的源的抽象。fs.createReadStream 方法是一个可读流的例子。</li><li>可写流是对一个可以写入数据的目标的抽象。fs.createWriteStream 方法是一个可写流的例子。</li><li>双向流既是可读的，又是可写的。TCP socket 就属于这种。</li><li>变换流是一种特殊的双向流，它会基于写入的数据生成可供读取的数据。</li></ul><p>所有的流都是EventEmitter的实例。它们发出可用于读取或写入数据的事件。然而，我们可以利用pipe方法以一种更简单的方式使用流中的数据。</p><p>在上面那段代码中，我们首先通过fs.createWriteStream()创建了一个可写流，用来存放最终合并的文件。然后使用fs.createReadStream()分别读取各个分片后的文件，再通过pipe()方式将读取的数据像倒水一样“倒”到可写流中，到监控到一杯水倒完后，马上接着倒下一杯，直到全部倒完为止。此时，全部文件合并完毕。</p><h3 id="追加文件方式合并"><a href="#追加文件方式合并" class="headerlink" title="追加文件方式合并"></a>追加文件方式合并</h3><p>追加文件方式合并指的是使用fs.appendFile()的方式来进行合并。fs.appendFile()的作用是异步地追加数据到一个文件，如果文件不存在则创建文件。data可以是一个字符串或buffer。例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.appendFile(<span class="string">'message.txt'</span>, <span class="string">'data to append'</span>, (err) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The "data to append" was appended to file!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用这种方法也可以将文件合并，虽然我没有在项目中实验，但通过在网上查的资料来看，性能强过buffer合并方式，但不及流合并方式。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><hr><p>这篇文章虽然是谈前台分片和后台合并，但是由于前台分片主要是使用webUploader实现的，因此侧重点都在后台合并上。</p><p>后台合并主要有3种方式：buffer合并、流合并、追加文件方式合并。三种方式各有各的特点，但是在大文件合并上，我推荐使用流方式合并，流合并占内存最少，效率最高，是处理大文件的最佳选择。</p>]]></content>
    
    <summary type="html">
    
      最近做了一个需求，需要上传镜像的tar包，小的3、5G，大的可能会达到20多G，而要求在浏览器中上传，因此普通的上传方式肯定无法满足需求，必须要使用到分片上传，前台分片后台就需要合并，一系列做完以后踩了很多坑，在这边总结记录一下。
    
    </summary>
    
    
      <category term="Node.js" scheme="https://tuobaye0711.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>深入探讨正斜杠和反斜杠</title>
    <link href="https://tuobaye0711.github.io/2017/11/17/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8%E6%AD%A3%E6%96%9C%E6%9D%A0%E5%92%8C%E5%8F%8D%E6%96%9C%E6%9D%A0/"/>
    <id>https://tuobaye0711.github.io/2017/11/17/深入探讨正斜杠和反斜杠/</id>
    <published>2017-11-17T02:00:52.000Z</published>
    <updated>2018-03-04T15:08:12.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><hr><p>为什么要写这篇文章呢？实际上还是源于上一篇文章<a href="http://tuobaye.com/2017/11/11/Nginx%20%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/" target="_blank" rel="noopener">Nginx 配置指南</a>里面一处配置代码给我带来的小纠结：</p><blockquote><p>你需要将静态网页和文件放到一个目录（例如/data/www），将图片等文件放到另一个目录（例如/data/images），然后在nginx.conf中进行配置。这需要在<em>http</em>模块下的<em>server</em>模块内新建两个<em>location</em>模块：</p></blockquote><blockquote> <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span> /data/www;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">location</span> /images/ &#123;</span><br><span class="line">            <span class="attribute">root</span> /data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p> 看起来很好理解吧~也可以直接把文件放到一块，直接location配置绝对路径：</p></blockquote><blockquote> <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">root</span>   F:\webapp\portal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>发现问题了么？上面的代码块root路径都是以斜杠(/)分隔的，下面的代码块的root路径却是以反斜杠(\)分隔的。两种不同的方式却能同样生效，这个是为什么呢？</p><h2 id="作为路径分隔符在windows和Unix系统下的区别"><a href="#作为路径分隔符在windows和Unix系统下的区别" class="headerlink" title="作为路径分隔符在windows和Unix系统下的区别"></a>作为路径分隔符在windows和Unix系统下的区别</h2><hr><p>在上文中的例子，不论是正斜杠还是反斜杠(\)，都是作为路径分隔符存在的，因此我们首先把他们作为路径分隔符，分别在windows和Unix两种不同内核的系统下进行一波测试。</p><p>windows（win7 64位系统）下：</p><p><img src="/2017/11/17/深入探讨正斜杠和反斜杠/windows.png" alt="windows"></p><p>Unix（Ubuntu 14.04.5）下：</p><p><img src="/2017/11/17/深入探讨正斜杠和反斜杠/Unix.png" alt="Unix"></p><p>可以看出，Unix内核系统，路径格式仅支持正斜杠(/)分隔，而windows的系统，正斜杠(/)反斜杠(\)都支持，这是个很奇妙的差别。</p><p>在查询了资料后，我才知道造成这种差别的深层次原因。</p><p>windows的命令行（CMD应用程序）跟早期的MS-DOS操作系统的命令格式是前向兼容的。而DOS系统其实有很多历史遗留问题。</p><p>DOS系统很大一部分参考（抄袭？）自加里·基尔代尔的更早的一款操作系统CP/M。</p><blockquote><p>CP/M是数字研究公司（1991年被Novell所兼并）在1974年开发，为8位CPU（如Intel 8080、Zilog Z80等）的个人电脑（PC）所设计的操作系统。在PC市场的黎明阶段，它成为被广泛应用的操作系统。可是因为在向16位CPU的转化上错失机会，在以IBM PC/AT以及IBM PC兼容机为中心的16位PC市场上惨败给Microsoft的MS-DOS，从而从市场上消失。虽然CP/M推出了为Intel 8086而设计的“CP/M 86”以及为Motorola 68000而设计的“CP/M 68k”等版本，但用户几乎不存在。</p></blockquote><p>由于CP/M系统是不支持目录的，/被拿来用作命令行参数的标识符，比如说dir /a, dir /w, dir /q等等（Unix用的是”-“），因此，当MS-DOS系统准备支持目录时，/已被占用，只能使用\来表示路径分隔符了。再后来，windows系统诞生之时，命令行因为要跟MS-DOS兼容，只能把DOS的特性沿用了下来，同时又给支持/作为路径分隔符，于是就造成了现在这种正斜杠(/)反斜杠(\)都支持作为路径分隔符的情况的出现。而Unix不存在这种历史遗留问题，从诞生之初就开始使用斜杠(/)作为路径分隔符，因此，两个系统在这种奇怪的地方出现了分叉。</p><p>而我当时的那段代码</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">root</span>   F:\webapp\portal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中的root路径，是直接从windows系统中粘贴的路径，因此就会出现这种反斜杠(\)做分隔符的奇怪场景。</p><p>对了，在测试过程中还发现了windows系统中使用/和\做分隔符的一个好玩的区别：</p><ul><li>使用\做分隔符时，在输入二级子目录（比如\zgit\<span style="color:red">zblog</span>）时，可以提示补全路径，输入z以后按一下tab就帮我把zblog给补全了</li><li>使用/做分隔符时，在输入二级子目录（比如\zgit\<span style="color:red">zblog</span>）时，并不能提示补全路径，他给我提示的还是1级子目录的列表，在我输入z以后按一下tab，他帮我补了一个zgit，我输入zb，按tab无反应。这实际上根本无可用补全功能。</li></ul><p>因此，仅在windows下做目录操作时，还是使用反斜杠(\)做分隔符系统支持度更强些，使用体验也更好一些。</p><h2 id="广义方面的区别"><a href="#广义方面的区别" class="headerlink" title="广义方面的区别"></a>广义方面的区别</h2><hr><h3 id="正斜杠"><a href="#正斜杠" class="headerlink" title="正斜杠(/)"></a>正斜杠(/)</h3><p>正斜杠(/)是我们平时很多时候都会用到的斜杠，我们经常会见到这样的写法：小明/小红/小强，你/我/他等等。这种格式在各种文章里面十分常见，表示“或”或者是“和”的意思。</p><p>浏览器中URL的层级URL标记符(//)以及路径分隔符(/)也是由正斜杠(/)组成，例如”<a href="https://zh.wikipedia.org/wiki/&quot;" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/&quot;</a>, 可以看到里面清一色的都是正斜杠(/)。使用正斜杠(/)的原因据说是web网站最早是在Unix系统下运行的，于是沿袭了Unix的那一套路径表述方式，因此使用正斜杠(/)作为分隔符。</p><p>正斜杠(/)也可以用作“除法”或者“分号”的作用，比如说”100÷4”我们在计算机上输入时，由于除号比较难输，经常就会写成”100/4”，效果是完全一致的。这种用法应该是从“分号”演化来的，毕竟”4/3”你看做“三分之四”还是看做“4除以3”，都是可以的。</p><p>连续两个正斜杠(/)可做“注释”之用，在C++/C#/Java/JavaScript/PHP等主流编程语言中基本上通用：</p><p>日期也可以使用正斜杠(/)分隔年月日，例如”2017/11/17”，也可以用美国标准”11/17/2017”，都表示2017年11月17日。</p><p>最后，斜线除了上述用法，也成为连字号的代替品。例如美国空军的飞机序号。”85-1000”是第1000架飞机在1985年制造，使用斜线”85-1001/1050”表示首批连串50部制造的飞机。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在控制台打印hello world!</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello world!'</span>)</span><br></pre></td></tr></table></figure><h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠(\)"></a>反斜杠(\)</h3><p>比起正斜杠(/)的诸多用处，反斜杠(\)的用处可就少多了。如果你还是动不动就用到反斜杠(\)，证明你肯定是一个程序员。</p><p>反斜杠(\)除了可以在windows下可以做路径分隔符外，最常用的功能就是做转义字符了。许多正则表达式语言都会将它视为字面意义和元字符之前的切换。例如\n是换行，\0是空字符，它们表示的实际上都是一个字符（char）；而在一些数学软件（如MATLAB）和维基百科上，可以使用反斜线输入希腊字母。\pi会转成π，\lambda会转成λ。由于反斜杠(\)存在转义字符的作用，因此我们常常在一些代码里面看到形如”C:\\Windows\\System32\\cmd.exe”的路径格式（<em>实际上你看到的双反斜杠(\)，我在markdown格式下输入了连续4个反斜杠…</em>），并不代表实际路径是这样的，而是其中连续两个反斜杠(\)发生了“化学反应”，第一个反斜杠(\)代表对后面部分进行转义，而对反斜杠(\)的转义还是反斜杠(\)，因此虽然连续输入两个反斜杠(\)，但是实际输出时只有一个反斜杠(\)。</p><p>另外，在某些程序语言的命令行中，例如在linux中,反斜线常被放在一行的末尾用来指示编译器忽略其后的换行符，使得下一行会被当做同一行语句。这种情况下，反斜线作为一个强制换行符，将代码拆解成“连续行”。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><hr><p>通读完这篇文章，相信你对正斜杠(/)和反斜杠(\)的作用不会再有疑惑了。最后，我再用一张图来总结一下两者各自的功能，以供各位看官整理记忆。</p><p><img src="/2017/11/17/深入探讨正斜杠和反斜杠/slash.png" alt="正斜杠和反斜杠"></p><h2 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h2><hr><p>看了这么一大堆正斜杠(/)和反斜杠(\)，是不是头都大了呢？没关系，要想记忆区分正斜杠(/)反斜杠(\)，可以把他们想象为笔画上的撇（丿）和捺（㇏），一撇一捺是为八，第一笔正斜，第二笔反斜（/\），这样是不是好记多了呢？</p>]]></content>
    
    <summary type="html">
    
      在我们写代码时，经常会遇到正斜杠（/）和反斜杠（\）带来的困惑，如果没有专门深入研究过，很容易搞混。大多数情况下不会真的出问题，但是一旦有一次不小心搞错了，还真挺难受的。只要您能仔细看完这篇文章，相信以后区分正斜杠（/）和反斜杠（\）就不会出现问题。
    
    </summary>
    
    
      <category term="拾遗" scheme="https://tuobaye0711.github.io/tags/%E6%8B%BE%E9%81%97/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 配置指南</title>
    <link href="https://tuobaye0711.github.io/2017/11/11/Nginx%20%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/"/>
    <id>https://tuobaye0711.github.io/2017/11/11/Nginx 配置指南/</id>
    <published>2017-11-11T02:50:50.000Z</published>
    <updated>2018-03-04T15:08:12.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Nginx？"><a href="#什么是Nginx？" class="headerlink" title="什么是Nginx？"></a>什么是Nginx？</h2><hr><p><img src="/2017/11/11/Nginx 配置指南/nginx.png" alt="Nginx"></p><p>没有什么文档比直接从<a href="">Nginx官网</a>来的更准确清晰了。</p><blockquote><p>Nginx [engine x] is an HTTP and reverse proxy server, a mail proxy server, and a generic TCP/UDP proxy server, originally written by Igor Sysoev. For a long time, it has been running on many heavily loaded Russian sites including Yandex, Mail.Ru, VK, and Rambler. According to Netcraft, Nginx served or proxied 29.43% busiest sites in October 2017. Here are some of the success stories: Dropbox, Netflix, Wordpress.com, FastMail.FM.</p></blockquote><p>Nginx [engine x]是最初由Igor Sysoev编写的HTTP和反向代理服务器，邮件代理服务器和通用TCP/UDP代理服务器。很长时间以来，它一直在许多重负荷的俄罗斯网站上运行，包括Yandex，Mail.Ru，VK和Rambler。根据Netcraft，2017年10月，Nginx服务或代理了 29.43％最繁忙的站点。下面是一些成功案例： Dropbox， Netflix， Wordpress.com， FastMail.FM。</p><p>Nginx的主要特性：</p><ul><li>Basic HTTP server features(基本的HTTP服务器功能)</li><li>Other HTTP server features(其他HTTP服务器功能)</li><li>Mail proxy server features(邮件代理服务器功能)</li><li>TCP/UDP proxy server features(TCP/UDP代理服务器功能)</li><li>Architecture and scalability(架构和可扩展性)</li></ul><h2 id="为什么要使用Nginx，跟以前用的tomcat有什么区别？"><a href="#为什么要使用Nginx，跟以前用的tomcat有什么区别？" class="headerlink" title="为什么要使用Nginx，跟以前用的tomcat有什么区别？"></a>为什么要使用Nginx，跟以前用的tomcat有什么区别？</h2><hr><p>虽然大家都叫web server，但是Nginx和tomcat有本质的不同。</p><p>Nginx常用来做静态内容服务器和代理服务器，用来放置静态资源或者转发请求给后面的应用服务；而tomcat常用来做应用容器，让java app在其中运行。</p><p>因此，严格来说，Nginx应该叫<span style="color:red">HTTP Server</span>，而tomcat则是一个<span style="color:red">Application Server</span></p><p>一个 HTTP Server关心的是HTTP协议层面的传输和访问控制，所以在Nginx上你可以看到代理、负载均衡等功能。客户端通过HTTP Server 访问服务器上存储的资源（HTML 文件、图片文件等等）。通过CGI技术，也可以将处理过的内容通过HTTP Server分发，但是一个HTTP Server始终只是把服务器上的文件如实的通过HTTP协议传输给客户端。</p><p>而应用服务器，则是一个应用执行的容器。它首先需要支持开发语言的 Runtime（对于 Tomcat 来说，就是 Java），保证应用能够在应用服务器上正常运行。其次，需要支持应用相关的规范，例如类库、安全方面的特性。对于 Tomcat 来说，就是需要提供 JSP/Sevlet 运行需要的标准类库、Interface 等。为了方便，应用服务器往往也会集成 HTTP Server 的功能，但是不如专业的 HTTP Server 那么强大，所以应用服务器往往是运行在 HTTP Server 的背后，执行应用，将动态的内容转化为静态的内容之后，通过 HTTP Server 分发到客户端。</p><p>于我个人来说，选择Nginx主要是因为其占用资源低的优点，比起tomcat，选择Nginx能给我释放大量的系统内存，供我其他IDE和chrome使用。</p><h2 id="nginx-conf配置文件指南"><a href="#nginx-conf配置文件指南" class="headerlink" title="nginx.conf配置文件指南"></a>nginx.conf配置文件指南</h2><hr><p>Nginx的安装，启动，关闭等步骤的教程在这里我们就不做赘述了，我们来主要谈一谈nginx.conf文件应该如何配置，这是nginx的灵魂所在。</p><h3 id="Nginx配置文件结构"><a href="#Nginx配置文件结构" class="headerlink" title="Nginx配置文件结构"></a>Nginx配置文件结构</h3><p>nginx包含由配置文件中指定的指令控制的模块。指令分为<strong>简单指令</strong>和<strong>块指令</strong>。</p><p>一个简单的指令由<strong>名称</strong>和<strong>参数</strong>组成，以空格分隔，并以分号（;）结束:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root /data/www;</span><br></pre></td></tr></table></figure><p>一个block指令和一个简单的指令有相同的结构，但是<strong>不是以分号结尾，而是用一系列由大括号（{和}）包围的附加指令来结束</strong>。如果一个block指令在大括号内可以有其他的指令，它就被称为一个context（上下文，例如：events，http，server和location）:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        #location / &#123;</span><br><span class="line">             proxy_pass   http:<span class="comment">//127.0.0.1:8090/;</span></span><br><span class="line">             proxy_redirect  http:<span class="comment">//127.0.0.1:8090/ /;</span></span><br><span class="line">             proxy_connect_timeout <span class="number">600</span>s;</span><br><span class="line">             proxy_read_timeout <span class="number">600</span>s;</span><br><span class="line">             proxy_send_timeout <span class="number">600</span>s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>置于任何context之外的配置文件中的指令被认为是在main context中。在<em>events</em>和<em>http</em>指令驻留在main content中，<em>server</em>是在<em>http</em>中，<em>location</em>则在<em>server</em>中。</p><p>#后面的部分是注释：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 这是一段注释</span><br></pre></td></tr></table></figure><h3 id="Nginx作为静态服务器使用"><a href="#Nginx作为静态服务器使用" class="headerlink" title="Nginx作为静态服务器使用"></a>Nginx作为静态服务器使用</h3><p>作为一个Web服务器，其最主要的任务是作为静态服务器使用。</p><p>你需要将静态网页和文件放到一个目录（例如/data/www），将图片等文件放到另一个目录（例如/data/images），然后在nginx.conf中进行配置。这需要在<em>http</em>模块下的<em>server</em>模块内新建两个<em>location</em>模块：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span> /data/www;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">location</span> /images/ &#123;</span><br><span class="line">            <span class="attribute">root</span> /data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来很好理解吧~也可以直接把文件放到一块，直接location配置绝对路径：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">root</span>   F:\webapp\portal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nginx在未配置监听端口的情况下默认监听80端口，因此，你可以通过在本地访问 <a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a> 或者 <a href="http://127.0.0.1/" target="_blank" rel="noopener">http://127.0.0.1/</a> 来访问你的网站。</p><p>怎么样？赶紧启动一下Nginx吧，你的静态网站已经可以在本地运行了！修改配置后重启Nginx的命令是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>如果您的Nginx无法启动或者出现其他错误，您可以尝试在 <em>/usr/local/nginx/logs</em> 或者 <em>/var/log/nginx</em> 中的 <em>access.log</em> 以及 <em>error.log</em> 中查找原因</p><h3 id="搭建简单的代理服务器"><a href="#搭建简单的代理服务器" class="headerlink" title="搭建简单的代理服务器"></a>搭建简单的代理服务器</h3><p>Nginx经常作为反向代理服务器来使用，这意味着Nginx服务器接收请求，将其传递给被代理服务器，从中检索响应并将其发送给客户端。</p><blockquote><p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。通过在网络各处放置反向代理节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。</p></blockquote><p>下面，我们将配置一个基本的代理服务器，它会处理本地图片文件的请求并返回其他的请求给被代理的服务器。在这个例子中，两个服务器将在一个Nginx实例上定义。</p><p>首先，在nginx的配置文件中增加一个server块来定义代理服务器，其中包含以下内容：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">    <span class="attribute">root</span> /data/up1;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将是一个简单的服务器，它监听8080端口。（如果不定义listen值的话，默认监听80端口）并将所有请求映射到本地文件系统上的目录/data/up1。创建这个目录并把index.html文件放进去。请注意，该root指令放置在server context中。当响应请求的 location 区块中，没有自己的 root 指令，上述的 root 指令才会被使用。</p><p>接下来，使用上一节中的服务器配置并对其进行修改，使其成为代理服务器配置。在第一个location块中，设置proxy_pass 指令，并在参数中配置指定的代理服务器的协议、名称和端口号（在我们的例子中是这样 <a href="http://localhost:8080）：" target="_blank" rel="noopener">http://localhost:8080）：</a></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:8080;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> /images/ &#123;</span><br><span class="line">        <span class="attribute">root</span> /data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将修改第二个location块，它将当前带有/images/前缀的请求映射到/data/images目录下，使其与具有典型文件扩展名的图像请求匹配。修改的location块如下所示：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ \.(gif|jpg|png)$</span> &#123;</span><br><span class="line">    <span class="attribute">root</span> /data/images;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该参数是一个正则表达式，它会匹配所有以.gif、.jpg 或者.png结尾的URI。一个正则表达式需要以~开头。匹配到的请求会被映射到/data/images目录下。</p><p>当Nginx通过location去响应一个请求时，它会先检测带有前缀的location指令，兽先是检测带有<strong>最长</strong>前缀的 location，其次检测正则表达式。如果被正则的匹配的规则匹配成功，Nginx会选择使用该location的规则，否则，会选择之前缓存的规则。</p><p>最终，一个代理服务器的配置结果如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:8080/;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ \.(gif|jpg|png)$</span> &#123;</span><br><span class="line">        <span class="attribute">root</span> /data/images;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该服务器将过滤以.gif、.jpg或者.png结尾的请求，并将它们映射到/data/images目录（通过添加URI到root指令的参数），并将所有其他请求传递给上述代理服务器。</p><p>要应用新配置，请保存修改后的配置文件，并nginx -s reload一下。</p><p>更多Nginx代理配置指令，尽在<a href="https://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">ngx_http_proxy_module</a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
    
    <summary type="html">
    
      Nginx是最初由Igor Sysoev编写的HTTP和反向代理服务器，邮件代理服务器和通用TCP/UDP代理服务器。很长时间以来，它一直在许多重负荷的俄罗斯网站上运行，包括Yandex，Mail.Ru，VK和Rambler。根据Netcraft，2017年10月，Nginx服务或代理了29.43％最繁忙的站点。下面是一些成功案例：Dropbox，Netflix，Wordpress.com，FastMail.FM。这篇文章可以帮你快速入门Nginx，了解Nginx的优势所在，并可以尝试搭建静态服务器和简单的反向代理服务器。
    
    </summary>
    
    
      <category term="Nginx" scheme="https://tuobaye0711.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>仅用1行核心JS代码实现一个轻量级富文本编辑器</title>
    <link href="https://tuobaye0711.github.io/2017/11/03/%E4%BB%85%E7%94%A81%E8%A1%8C%E6%A0%B8%E5%BF%83JS%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>https://tuobaye0711.github.io/2017/11/03/仅用1行核心JS代码实现一个轻量级富文本编辑器/</id>
    <published>2017-11-03T09:01:21.000Z</published>
    <updated>2018-07-26T02:01:48.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>把<a href="https://tuobaye.com/demo/zEditor/index" target="_blank" rel="noopener">demo</a>放在显眼的位置</p><hr><p>富文本编辑器是我们在生活中非常常用到的编辑工具，现在有很多功能完备且强大的编辑器，比如<a href="https://github.com/quilljs/quill" target="_blank" rel="noopener">Quill Rich Text Editor</a>、<a href="http://ueditor.baidu.com/website/" target="_blank" rel="noopener">ueditor</a>等，都是很优秀的富文本编辑器。甚至说我们每个人都会用到的word，才是最优秀、国民度最高的富文本编辑器。</p><p>今天我们要实现一个轻量级的编辑器，主要利用的是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand" target="_blank" rel="noopener">document.execCommand</a>。</p><blockquote><p>当一个HTML文档切换到设计模式(designMode)时，文档对象暴露 execCommand方法，该方法允许运行命令来操纵可编辑区域的内容。大多数命令影响文档的选择（粗体，斜体等），而其他命令插入新元素（添加链接）或影响整行（缩进）。当使用 contentEditable时，调用 execCommand() 将影响当前活动的可编辑元素。</p></blockquote><p>用document.execCommand和contentEditable相互配合，就可以实现我们想要实现的功能。</p><p>在查阅了execCommand的文档后，我们决定实现以下功能</p><ol><li>选中文字样式调整<ul><li>斜体</li><li>粗体</li><li>下划线</li><li>删除线</li></ul></li><li>对齐方式调整<ul><li>左对齐</li><li>右对齐</li><li>居中</li><li>两端对齐</li></ul></li><li>缩进调整<ul><li>右缩进</li><li>左缩进</li></ul></li><li>列表操作<ul><li>有序列表</li><li>无序列表</li></ul></li><li>上下标</li><li>文字操作<ul><li>全选</li><li>复制</li><li>粘贴</li></ul></li><li>基本的字号调整</li><li>基本的颜色调整</li><li>基本的字体调整</li><li>undo&amp;redo</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><hr><p>说到编辑器，最基本的会分为上下两部分</p><blockquote><ul><li>上部分为控制区域，用于对文本进行各种控制修改</li><li>下部分为文本区域，用于输入和展示文本的样式</li></ul></blockquote><p>因此我们可以先在HTML里把两部分简单画出来</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"control-area"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"text-area"</span> <span class="attr">contenteditable</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，既然文本区域要可编辑，要加上contenteditable属性，这样就可以自如的在文本区域输入文字了。OK,编辑器雏形已经出来了~</p><p>接下来要对两部分分别进行操作，在控制区域，应该就是各种按钮。参考document.execCommand的语法：<br><img src="/2017/11/03/仅用1行核心JS代码实现一个轻量级富文本编辑器/execCommand.png" alt="document.execCommand"></p><p>主要控制到样式的有两个api：aCommandName和aValueArgument。同时，命令名aCommandName每条execCommand都会有，aCommandName和aValueArgument。因此我们需要在每个按钮上传递两个变量。第一个是必填项aCommandName，第二个是选填项aValueArgument。我们考虑采用HTML5的新属性data-*传递这两个参数:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--调整为斜体--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">data-command</span>=<span class="string">'italic'</span> <span class="attr">onclick</span>=<span class="string">"changeStyle(this.dataset)"</span>&gt;</span>斜体<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--调整字号为1号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">data-command</span>=<span class="string">'fontSize'</span> <span class="attr">data-value</span>=<span class="string">"1"</span> <span class="attr">onclick</span>=<span class="string">"changeStyle(this.dataset)"</span>&gt;</span>1号<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>上面是两个基本按钮示例，一个是不传参的，一个是传参的，然后在js端做一个判断即可实现功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> changeStyle = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//一行核心代码即可实现基本编辑器功能</span></span><br><span class="line">    data.value? <span class="built_in">document</span>.execCommand(data.command, <span class="literal">false</span>, data.value):<span class="built_in">document</span>.execCommand(data.command, <span class="literal">false</span>, <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很简单呢？</p><p>最后，只有两个按钮肯定是不够的，我们要把按钮数和编辑器的功能扩充丰富起来。我们就按照第一节整理的决定要实现的功能列表列出来的功能，按照分类，一一来实现。最后，再把按钮和文本区域的样式美化一下，即可实现我们这个轻量级富文本编辑器啦~</p><p>这是我们的预览图：<br><img src="/2017/11/03/仅用1行核心JS代码实现一个轻量级富文本编辑器/zEditor.png" alt="zEditor"></p><p>大家可以访问<a href="https://tuobaye.com/demo/zEditor/index" target="_blank" rel="noopener">我的博客</a>尝试一下这个小小富文本编辑器，也希望能去我的<a href="https://github.com/tuobaye0711/zEditor" target="_blank" rel="noopener">github项目</a>上点颗star,谢谢啦~</p><p>顺道贴一个codepen的预览，有些网络可能加载不出来…</p><p></p><p data-height="744" data-theme-id="dark" data-slug-hash="LOZRaL" data-default-tab="html,result" data-user="tuobaye0711" data-embed-version="2" data-pen-title="zEditor" class="codepen">See the Pen <a href="https://codepen.io/tuobaye0711/pen/LOZRaL/" target="_blank" rel="noopener">zEditor</a> by zhleven (<a href="https://codepen.io/tuobaye0711" target="_blank" rel="noopener">@tuobaye0711</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><hr><p>实际上，我们这个富文本编辑器是一种最最简单的实现，仅仅是对contentEditable和document.execCommand进行了一层封装，所有的样式实现都是调用的这同一条api。</p><p>在当前流行的真正功能强大的富文本编辑器中，基本都是实现了自己的contentEditable，抛弃了对浏览器原生的contentEditable特性的依赖。大家都说富文本编辑器是个天坑，事实也正是如此，原生的document.execCommand实现的功能太少，BUG太多，如果使用自己写的功能来编辑文字，又会破坏contentEditable的undo/redo栈。总之，contentEditable最大的特点就是样式、html语意环境跟调用页面混合在一起，非常容易出现覆盖现象，而牛逼的富文本编辑器基本上都会使用一套自己的事件监听机制来实现类似contentEditable的功能，这些东西太繁琐太复杂，不在这里的讨论范围之内了~</p>]]></content>
    
    <summary type="html">
    
      富文本编辑器是我们在生活中非常常用到的编辑工具，现在有很多功能完备且强大的编辑器，比如Quill Rich Text Editor、ueditor等，都是很优秀的富文本编辑器。甚至说我们每个人都会用到的word，才是最优秀、国民度最高的富文本编辑器。这篇文章使用极少的代码，实现了一个简洁、无任何依赖的轻量级富文本编辑器。
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://tuobaye0711.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>通过microtasks和macrotasks看JavaScript异步任务执行顺序</title>
    <link href="https://tuobaye0711.github.io/2017/10/24/%E9%80%9A%E8%BF%87microtasks%E5%92%8Cmacrotasks%E7%9C%8BJavaScript%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>https://tuobaye0711.github.io/2017/10/24/通过microtasks和macrotasks看JavaScript异步任务执行顺序/</id>
    <published>2017-10-24T03:08:09.000Z</published>
    <updated>2018-03-04T15:08:12.827Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-初探-—-setTimeout-的那些事儿"><a href="#1-初探-—-setTimeout-的那些事儿" class="headerlink" title="1. 初探 — setTimeout()的那些事儿"></a>1. 初探 — setTimeout()的那些事儿</h3><hr><p>相信很多人在初学JavaScript的时候都遇到过类似的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// part1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;,<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// part2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>萌新们看到这个，肯定觉得很简单。part1输出顺序是1,3,4,2;part2输出顺序是1,2,3,4嘛。显而易见，part1中在打印2的时候延迟了100ms，所以被放到了队列的尾端执行，理所当然的最后输出；part2中虽然调用了setTimeout函数，但是延迟设置为0ms，实际上并未延迟，因此应该立即执行，所以输出顺序应该是1,2,3,4。</p><p>看到这里，很多人应该都知道了，上面的说法实际上是错误的。</p><blockquote><p>setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。</p></blockquote><p>上面的这段文字摘自<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">阮一峰的博客</a>，即使你的延迟设定的是0，setTimeout仍然会将你的函数给放到队列最尾端，等你的当前任务执行完毕以后,才会去执行该函数。</p><h3 id="2-深入-—-setTimeout-和Promise同场竞技时是什么样呢？"><a href="#2-深入-—-setTimeout-和Promise同场竞技时是什么样呢？" class="headerlink" title="2. 深入 — setTimeout()和Promise同场竞技时是什么样呢？"></a>2. 深入 — setTimeout()和Promise同场竞技时是什么样呢？</h3><hr><p>众所周知，Promise是ES6发布的一种非常流行的异步实现方案，当Promise和setTimeout同时出现在一段代码中，他们的执行顺序是什么样子的呢？请看下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">100000</span> ; i&gt;<span class="number">0</span> ; i-- )&#123;</span><br><span class="line">        i==<span class="number">1</span> &amp;&amp; resolve()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>如果按照正常逻辑分析，应该是这样的：</p><ol><li>当运行到setTimeout时，会把setTimeout的回调函数console.log(1)放到任务队列里去，然后继续向下执行。</li><li>接下来会遇到一个Promise。首先执行打印console.log(2)，然后执行for循环，即时for循环要累加到10万，也是在执行栈里面，等待for循环执行完毕以后，将Promise的状态从fulfilled切换到resolve，随后把要执行的回调函数，也就是then里面的console.log(4)推到任务队列里面去。接下来马上执行马上console.log(3)。</li><li>然后出Promise，还剩一个同步的console.log(5)，直接打印。这样第一轮下来，已经依次打印了2，3，5。</li><li>然后再读取任务队列，任务队列里还剩console.log(1)和console.log(4)，因为任务队列是队列嘛，肯定遵循的先进先出的策略，因此更早入列的setTimeout()的回调函数先执行，打印1，最后剩下Promise的回调，打印4。</li></ol><p>因此一通分析下来，得到的打印结果是2,3,5,1,4。那我们实际试一下呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>啊嘞嘞？跟我们一开始想象的貌似有点不一样啊！是什么原因导致了原本应该在setTimeout回调后面的Promise的回调反而跑到前面去执行了呢？</p><p>为了搞清这个问题，我专门去翻阅了一下资料，首先找到了<a href="https://promisesaplus.com/#point-67" target="_blank" rel="noopener">Promises/A+标准</a>里面提到：</p><blockquote><p>  Here “platform code” means engine, environment, and promise implementation code. In practice, this requirement ensures that onFulfilled and onRejected execute asynchronously, after the event loop turn in which then is called, and with a fresh stack. <span style="color:red">This can be implemented with either a “macro-task” mechanism such as setTimeout or setImmediate, or with a “micro-task” mechanism such as MutationObserver or process.nextTick. </span>Since the promise implementation is considered platform code, it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called.</p></blockquote><p>这里提到了micro-task和macro-task这两个概念，并分别列举了两种情况：setTimeout和setImmediate属于macro-task，MutationObserver和process.nextTick属于micro-task。但并没有进一步的详述，于是我以此为线索进一步搜索资料，找到<a href="https://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context" target="_blank" rel="noopener">stackoverflow上的一个问答</a>，终于让我的疑惑得到解决。</p><p>macrotasks和microtasks的划分：</p><h4 id="macrotasks"><a href="#macrotasks" class="headerlink" title="macrotasks:"></a>macrotasks:</h4><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>requestAnimationFrame</li><li>I/O</li><li>UI rendering</li></ul><h4 id="microtasks"><a href="#microtasks" class="headerlink" title="microtasks:"></a>microtasks:</h4><ul><li>process.nextTick</li><li>Promises</li><li>Object.observe</li><li>MutationObserver</li></ul><p>那我们上面提到的任务队列到底是什么呢？跟macrotasks和microtasks有什么联系呢？</p><blockquote><ul><li>An event loop has one or more task queues.(task queue is macrotask queue)</li><li>Each event loop has a microtask queue.</li><li>task queue = macrotask queue != microtask queue</li><li>a task may be pushed into macrotask queue,or microtask queue</li><li>when a task is pushed into a queue(micro/macro),we mean preparing work is finished,so the task can be executed now.</li></ul></blockquote><p>翻译一下就是：</p><ul><li>一个事件循环有一个或者多个任务队列；</li><li>每个事件循环都有一个microtask队列</li><li>macrotask队列就是我们常说的任务队列，microtask队列不是任务队列</li><li>一个任务可以被放入到macrotask队列，也可以放入microtask队列</li><li>当一个任务被放入microtask或者macrotask队列后，准备工作就已经结束，这时候可以开始执行任务了。</li></ul><p>可见，setTimeout和Promises不是同一类的任务，处理方式应该会有区别，具体的处理方式有什么不同呢？我从<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly&amp;utm_medium=email" target="_blank" rel="noopener">这篇文章</a>里找到了下面这段话：</p><blockquote><p>Microtasks are usually scheduled for things that should happen straight after the currently executing script, such as reacting to a batch of actions, or to make something async without taking the penalty of a whole new task. The microtask queue is processed after callbacks as long as no other JavaScript is mid-execution, and at the end of each task. Any additional microtasks queued during microtasks are added to the end of the queue and also processed. Microtasks include mutation observer callbacks, and as in the above example, promise callbacks.</p></blockquote><p>通俗的解释一下，<font color="red">microtasks的作用是用来调度应在当前执行的脚本执行结束后立即执行的任务。</font>  例如响应事件、或者异步操作，以避免付出额外的一个task的费用。</p><p>microtask会在两种情况下执行：</p><ol><li>任务队列(macrotask = task queue)回调后执行，前提条件是当前没有其他执行中的代码。</li><li>每个task末尾执行。</li></ol><p>另外在处理microtask期间，如果有新添加的microtasks，也会被添加到队列的末尾并执行。</p><p>也就是说执行顺序是：</p><p>开始 -&gt; <font color="red">取task queue第一个task执行 -&gt; 取microtask全部任务依次执行 -&gt; 取task queue下一个任务执行 -&gt; 再次取出microtask全部任务执行 -&gt; …  </font>  这样循环往复</p><blockquote><p>Once a promise settles, or if it has already settled, it queues a microtask for its reactionary callbacks. This ensures promise callbacks are async even if the promise has already settled. So calling .then(yey, nay) against a settled promise immediately queues a microtask. This is why promise1 and promise2 are logged after script end, as the currently running script must finish before microtasks are handled. promise1 and promise2 are logged before setTimeout, as microtasks always happen before the next task.</p></blockquote><p>Promise一旦状态置为完成态，便为其回调(.then内的函数)安排一个microtask。</p><p>接下来我们看回我们上面的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">100000</span> ; i&gt;<span class="number">0</span> ; i-- )&#123;</span><br><span class="line">        i==<span class="number">1</span> &amp;&amp; resolve()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>按照上面的规则重新分析一遍：</p><ol><li>当运行到setTimeout时，会把setTimeout的回调函数console.log(1)放到任务队列里去，然后继续向下执行。</li><li>接下来会遇到一个Promise。首先执行打印console.log(2)，然后执行for循环，即时for循环要累加到10万，也是在执行栈里面，等待for循环执行完毕以后，将Promise的状态从fulfilled切换到resolve，<font color="red">随后把要执行的回调函数，也就是then里面的console.log(4)推到microtask里面去。</font>接下来马上执行马上console.log(3)。</li><li>然后出Promise，还剩一个同步的console.log(5)，直接打印。这样第一轮下来，已经依次打印了2，3，5。</li><li>现在第一轮任务队列已经执行完毕，没有正在执行的代码。符合上面讲的microtask执行条件，因此会将microtask中的任务优先执行，因此执行console.log(4)</li><li>最后还剩macrotask里的setTimeout放入的函数console.log(1)最后执行。</li></ol><p>如此分析输出顺序是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>看吧，这次分析对了呢ヾ(◍°∇°◍)ﾉﾞ</p><h3 id="3-总结和参考资料"><a href="#3-总结和参考资料" class="headerlink" title="3. 总结和参考资料"></a>3. 总结和参考资料</h3><hr><p>microtask和macrotask看起来容易混淆，实际上还是很好区分的。macrotask就是我们常说的任务队列(task queue)。</p><p>JavaScript执行顺序可以简要总结如下：</p><p>开始 -&gt; <font color="red">取task queue第一个task执行 -&gt; 取microtask全部任务依次执行 -&gt; 取task queue下一个任务执行 -&gt; 再次取出microtask全部任务执行 -&gt; …  </font></p><p>循环往复，直至两个队列全部任务执行完毕。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly&amp;utm_medium=email" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules</a><br><a href="https://github.com/YuzuJS/setImmediate" target="_blank" rel="noopener">github-setImmediate.js</a><br><a href="https://promisesaplus.com/#point-67" target="_blank" rel="noopener">Promises/A+</a><br><a href="https://www.zhihu.com/question/36972010" target="_blank" rel="noopener">知乎-Promise的队列与setTimeout的队列有何关联？</a><br><a href="https://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context" target="_blank" rel="noopener">stack overflow-Difference between microtask and macrotask within an event loop context</a><br><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">阮一峰-JavaScript 运行机制详解：再谈Event Loop</a></p>]]></content>
    
    <summary type="html">
    
      JS引擎是单线程的。这意味着在任何环境中，只有一段JS代码会被执行。当JS引擎开始执行一个函数时，它就会把这个函数执行完，也就是说只有执行完这段代码才会继续执行后面的代码。这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。因此，JavaScript采用了一种“异步”的方式，在浏览器端，耗时很长的操作都应该异步执行。本文，我们将讨论几种常见的异步操作方式，并且通过将任务划分为microtasks和macrotasks来分析异步任务的执行顺序。
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://tuobaye0711.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>一个简单的Promise实现</title>
    <link href="https://tuobaye0711.github.io/2017/10/17/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84promise%E5%AE%9E%E7%8E%B0/"/>
    <id>https://tuobaye0711.github.io/2017/10/17/一个简单的promise实现/</id>
    <published>2017-10-17T07:54:45.000Z</published>
    <updated>2018-03-04T15:08:12.819Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/10/17/一个简单的promise实现/promise.png" alt="promise/A+"></p><blockquote><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p></blockquote><p>通常我们是这么定义和使用promise的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSomethingAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//异步请求,这里简单的用setTimeout模拟异步</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            resolve(<span class="string">'got it!'</span>);</span><br><span class="line">        &#125;,<span class="number">5000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">getSomethingAsync().then(<span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//一些处理</span></span><br><span class="line">    <span class="keyword">let</span> information = id;</span><br><span class="line">    <span class="built_in">console</span>.log(information)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这例中主要涉及了Promise的两个核心，一个是then，一个是resolve。据此，我们可以写出一个最基础的Promise的架子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//value用来存储向resolve传递的值，callbacks用来存储已注册的回调函数</span></span><br><span class="line">    <span class="keyword">var</span> value = <span class="literal">null</span>,</span><br><span class="line">        callbacks = [];  <span class="comment">//callbacks为数组，因为可能同时有很多个回调</span></span><br><span class="line">    <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//将注册的回调函数依次压入栈中</span></span><br><span class="line">        callbacks.push(onFulfilled);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//当调用resolve函数时，根据传入的value，依次执行已注册的回调函数</span></span><br><span class="line">        callbacks.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            callback(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们分别分析一下then和resolve的作用,首先是then：</p><p><img src="/2017/10/17/一个简单的promise实现/Promise.prototype.then.png" width="50%" height="50%"></p><p>注册回调函数的作用很明显，就是在Promise的异步操作执行成功时，将需要执行的回调函数压入callbacks队列中。</p><p>同时，then函数要实现类似于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getSomethingAsync().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//一些处理</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//二些处理</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//三些处理</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>的功能，即链式调用，仅需一行代码即可实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//将注册的回调函数依次压入栈中</span></span><br><span class="line">    callbacks.push(onFulfilled);</span><br><span class="line">    <span class="comment">//一行代码实现链式调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>是不是很巧妙呢？</p><hr><p>实现了then的基本功能，我们再回过头来看resolve。resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。这样，当Promise实例生成以后，可以用then方法指定resolved状态。</p><p>由此可见，resolve状态下，还有一件必须要完成的事情是状态切换:</p><ul><li>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。</li></ul><p>pending -&gt; fulfilled/pending -&gt; rejected</p><p>我们接下来就在resolve里面加上状态切换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="literal">null</span>,</span><br><span class="line">        callbacks = [],</span><br><span class="line">        <span class="comment">//初始状态置为pending</span></span><br><span class="line">        state = <span class="string">'pending'</span>;</span><br><span class="line">    <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//假如调用then函数时，状态仍为pending，这时候需要将回调函数压入到callbacks栈中</span></span><br><span class="line">    <span class="keyword">if</span> (state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    callbacks.push(onFulfilled);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//假如调用then函数时，状态不是pending，则直接调用</span></span><br><span class="line">        onFulfilled(value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    value = newValue;</span><br><span class="line">    <span class="comment">//将状态切换为fulfilled</span></span><br><span class="line">    state = <span class="string">'fulfilled'</span>;</span><br><span class="line">        callbacks.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            callback(value)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    fn(resolve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就实现了一个最基础的Promise。等等，是不是还缺了什么？如果在then方法注册回调之前，resolve函数就执行了，怎么办？比如promise内部的函数是同步函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        resolve(<span class="number">8384</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">getSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 一些处理</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这么做显然不对，我们必须将resolve放到队列尾端，以保证在resolve执行前，所有then函数的回调都已经注册完毕，因此我们再加一个延时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    value = newValue;</span><br><span class="line">    state = <span class="string">'fulfilled'</span>;</span><br><span class="line">    <span class="comment">// 放到队列尾端执行回调</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        callbacks.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            callback(value)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们一个最基本的Promise就写完了，为了便于理解逻辑，暂时还没加rejected的状态切换，后面有机会咱再继续丰富我们的Promise源码~下面贴一下完整的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="literal">null</span>,</span><br><span class="line">    callbacks = [],</span><br><span class="line">    state = <span class="string">"pending"</span>;</span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === <span class="string">"pending"</span>) &#123;</span><br><span class="line">      callbacks.push(onFulfilled);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">//一行即可实现链式调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    onFulfilled(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    value = newValue;</span><br><span class="line">    state = <span class="string">"fulfilled"</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      callbacks.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        callback(value);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击<a href="https://codepen.io/tuobaye0711/pen/BwMQyL?editors=0010" target="_blank" rel="noopener">这里</a>查看codepen完整代码示例~</p>]]></content>
    
    <summary type="html">
    
      Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。本文采用最简单的方法，实现了一个基本的Promise雏形
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://tuobaye0711.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>坚持这件事儿</title>
    <link href="https://tuobaye0711.github.io/2017/09/15/%E5%9D%9A%E6%8C%81%E8%BF%99%E4%BB%B6%E4%BA%8B%E5%84%BF/"/>
    <id>https://tuobaye0711.github.io/2017/09/15/坚持这件事儿/</id>
    <published>2017-09-15T13:54:40.000Z</published>
    <updated>2018-03-04T15:08:12.822Z</updated>
    
    <content type="html"><![CDATA[<p>  无数次想要开一个博客，把自己学习中的感悟和开发工作中遇到的典型问题记下来，给自己提个醒，也可以给他人做个参考，然而拖延症晚期，一拖再拖，总算还是在17年过去了四分之三的时候下了决心，把这个博客搭起来了。希望自己坚持下去。<br>  说起坚持这件事情，前两天同学聚会，毕业都一年多了，大家一起吃个饭很开心。但是大家都说我胖了，胖了。。。说我脸跟吹气球似的，我明明才150好吗？不过这确实让我正视起体重的问题。工作这段时间，工资没见涨多少，体重蹭蹭蹭的增。所以下定决心，狠出了一把血买了台跑步机。女朋友嘲讽我不可能坚持下来的，我觉得我能，我们打了个赌，谁输谁赢只能交给时间咯~<br>  不啰嗦了，尽快把博客运转起来，坚持更新，fighting！</p><p><img src="/2017/09/15/坚持这件事儿/930753.jpg" alt="fighting"></p>]]></content>
    
    <summary type="html">
    
      hello, my blog!
    
    </summary>
    
    
      <category term="随笔" scheme="https://tuobaye0711.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
